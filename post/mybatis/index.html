<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Mybatis | Gridea</title>
<meta name="description" content="温故而知新" />
<link rel="shortcut icon" href="https://zjt-zjt.github.io/favicon.ico?v=1576065062000">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://zjt-zjt.github.io/styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://zjt-zjt.github.io">
  <img class="avatar" src="https://zjt-zjt.github.io/images/avatar.png?v=1576065062000" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Mybatis
            </h2>
            <div class="post-info">
              <span>
                2019-04-17
              </span>
              <span>
                20 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <!-- more -->
<h2 id="mybatis介绍">Mybatis介绍</h2>
<h2 id="mybatis简单使用">Mybatis简单使用</h2>
<ol>
<li>
<p>初始化SqlSessionFactory对象</p>
<p>SqlSessionFactory对象需要从一个核心配置文件中构建，因此我们创建SqlSessionFactory对象之前需要先配置一个Mybatis核心配置文件</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;!-- 引入外部properties文件,路径从类路径的根目录开始 --&gt;
    &lt;properties resource=&quot;jdbc.properties&quot; /&gt;

    &lt;settings&gt;
        &lt;!-- 开启将数据库中下划线连接的字段自动映射为Java的小驼峰命名 --&gt;
        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
    &lt;/settings&gt;

    &lt;!-- 定义类型别名，在xxxMapper.xml文件中就可以用别名代替很长的类名 --&gt;
    &lt;typeAliases&gt;
        
            &lt;!-- 单个类配置别名 --&gt;
&lt;!--        &lt;typeAlias type=&quot;com.lanou3g.mybatis.bean.User&quot; alias=&quot;User&quot; /&gt;--&gt;
        
            &lt;!-- 统一配置某个包下所有类的别名, 会使用 Bean 的首字母小写的类名来作为它的别名。 --&gt;
        &lt;package name=&quot;com.lanou3g.mybatis.bean&quot; /&gt;
    &lt;/typeAliases&gt;


    &lt;!-- 配置不同环境的参数 --&gt;
    &lt;environments default=&quot;development&quot;&gt;
        &lt;!-- 开发环境数据库、事务配置 --&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;!-- 事务管理使用JDBC的事务 --&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;!-- 配置开发环境数据源 --&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;${jdbc.user}&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;
                &lt;!-- 将所有driver.开头的参数，附加到url属性的值后面上 --&gt;
                &lt;property name=&quot;driver.characterEncoding&quot; value=&quot;utf8&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;

    &lt;!-- 将mapper SQL映射文件包含进来 --&gt;
    &lt;mappers&gt;
        &lt;!-- 将通过XML方式配置的mapper引入进来 --&gt;
        &lt;mapper resource=&quot;mapper/userMapper.xml&quot;/&gt;
        &lt;!-- 将通过注解方式配置的mapper引入进来 --&gt;
&lt;!--        &lt;mapper class=&quot;com.lanou3g.mybatis.mapper.UserMapper&quot; /&gt;--&gt;

        &lt;!-- 将com.lanou3g.mybatis.mapper包下所有通过注解方式配置的mapper引入进来 --&gt;
&lt;!--        &lt;package name=&quot;com.lanou3g.mybatis.mapper&quot;/&gt;--&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<p>构建对象</p>
<pre><code class="language-java">// 1. 初始化mybatis配置
String confPath = &quot;mybatis_conf.xml&quot;;
InputStream in = Resources.getResourceAsStream(confPath);

// 2. 构建SqlSessionFactory对象
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in);
</code></pre>
</li>
<li>
<p>创建SqlSession对象</p>
<p>通过上一步的SqlSessionFactory对象可以获取到负责执行SQL语句的SqlSession对象</p>
<pre><code class="language-java">// 3. 获取SqlSession对象，默认事务不自动提交
// SqlSession sqlSession = sqlSessionFactory.openSession();
// 获取一个自动提交事务的sqlSession
SqlSession sqlSession = sqlSessionFactory.openSession(true);
</code></pre>
</li>
<li>
<p>用SqlSession对象从Mybatis中获取Mapper接口的实现类</p>
<pre><code class="language-java">// 4. 获取Mapper
UserMapper mapper = sqlSession.getMapper(UserMapper.class);
</code></pre>
</li>
<li>
<p>编写Mapper对象的xml配置文件</p>
<p>XML格式的Mapper配置文件类似于接口的实现类，它指定了具体要执行的SQL语句，以及结果集如何映射。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.lanou3g.mybatis.mapper.UserMapper&quot;&gt;
    &lt;select id=&quot;queryAllUser&quot; resultType=&quot;user&quot;&gt;
        select * from user
     &lt;/select&gt;

    &lt;insert id=&quot;insertUser&quot;&gt;
      insert into user (username,nick_name,email)
      values (#{username},#{nickName},#{email})
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre>
</li>
</ol>
<h2 id="深入了解mybatis">深入了解Mybatis</h2>
<h3 id="主要组件">主要组件</h3>
<h4 id="核心配置文件">核心配置文件</h4>
<p>核心配置文件是Mybatis的入口，它里面可以配置mybatis的具体参数、数据源、类型别名、关联映射文件等。。</p>
<p>具体的参数配置说明参见：</p>
<p><a href="https://mybatis.org/mybatis-3/zh/configuration.html">Mybatis3核心配置文件官方说明</a></p>
<h4 id="sqlsessionfactory">SqlSessionFactory</h4>
<p>一个SqlSessionFactory只能连接一个数据库实例，如果需要连接多个数据库，需要构建多个SqlSessionFactory对象。</p>
<p>在构建SqlSesssionFactory时可以指定environment的id，表示使用指定的数据源来构建factory对象</p>
<pre><code class="language-java">SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in, &quot;dev&quot;);
</code></pre>
<h4 id="sqlsession">SqlSession</h4>
<p>一个SqlSession对象代表一次到数据的会话，该对象有一下功能：</p>
<ul>
<li>获取Mapper实现类</li>
<li>管理事务操作</li>
</ul>
<blockquote>
<p>注意： SqlSession对象是非线程安全的，在多线程环境下，建议不要作为类的实例属性来用。</p>
</blockquote>
<h4 id="mapper">Mapper</h4>
<ul>
<li>
<p>Mapper接口类</p>
<p>定义了增删盖查的方法。注意，必须是接口类型，而且方法只需要定义就可以了。</p>
</li>
<li>
<p>Mapper配置文件</p>
<p>Mapper配置文件中就是负责实现接口中的方法，它定义了具体要执行什么SQL语句，如何映射结果集。</p>
<ul>
<li>配置文件中select、delete、update、insert标签的id必须是对应接口中的方法名。</li>
<li>mapper文件的namespace属性需要对应Mapper接口的完全类型限定名。</li>
</ul>
</li>
</ul>
<h3 id="深入mybatis核心配置文件">深入Mybatis核心配置文件</h3>
<p>具体的参数配置说明参见：</p>
<p><a href="https://mybatis.org/mybatis-3/zh/configuration.html">Mybatis3核心配置文件官方说明</a></p>
<h3 id="深入mybatis映射配置文件">深入Mybatis映射配置文件</h3>
<h4 id="crud语句定义">CRUD语句定义</h4>
<h5 id="查询语句">查询语句</h5>
<p>接口中</p>
<pre><code class="language-java">List&lt;User&gt; queryAllUser();

User queryUserById(Integer id);
</code></pre>
<p>xml配置文件中</p>
<pre><code class="language-xml">&lt;select id=&quot;queryAllUser&quot; resultType=&quot;user&quot;&gt;
    select * from user
&lt;/select&gt;

&lt;select id=&quot;queryUserById&quot; resultType=&quot;user&quot;&gt;
    select * from user where id = #{id}
&lt;/select&gt;
</code></pre>
<h5 id="插入语句">插入语句</h5>
<h6 id="普通插入语句">普通插入语句</h6>
<p>接口中</p>
<pre><code class="language-java">int insertUser(User user);
</code></pre>
<p>xml配置文件中</p>
<pre><code class="language-xml">&lt;insert id=&quot;insertUser&quot;&gt;
    insert into user (username,nick_name,email)
    values (#{username},#{nickName},#{email})
&lt;/insert&gt;
</code></pre>
<h6 id="如何返回数据库自增的id">如何返回数据库自增的ID</h6>
<pre><code class="language-xml">&lt;!-- 给insert语句添加useGeneratedKeys、keyProperty后，mybatis会将自增的id值直接赋值到传进来的user对象的id属性上
        useGeneratedKeys: 指定需要获取数据库自增的id
        keyProperty: 指定自增地段的名称
     --&gt;
&lt;insert id=&quot;insertUser&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
    insert into user (username,nick_name,email)
    values (#{username},#{nickName},#{email})
&lt;/insert&gt;
</code></pre>
<h5 id="删除语句">删除语句</h5>
<p>接口中</p>
<pre><code class="language-java">void deleteUserById(Integer id);
</code></pre>
<p>XML配置中</p>
<pre><code class="language-xml">&lt;delete id=&quot;deleteUserById&quot;&gt;
    delete from user where id = #{id}
&lt;/delete&gt;
</code></pre>
<h5 id="更新语句">更新语句</h5>
<p>接口中</p>
<pre><code class="language-java">void updateUser(User user);
</code></pre>
<p>XML配置中</p>
<pre><code class="language-xml">&lt;update id=&quot;updateUser&quot;&gt;
    update user set password = #{password} where id = #{id}
&lt;/update&gt;
</code></pre>
<h4 id="接口中的参数如果传递到sql中">接口中的参数如果传递到SQL中</h4>
<h5 id="简单类型参数">简单类型参数</h5>
<p>接口中：</p>
<pre><code class="language-java">void deleteUserById(Integer id);
</code></pre>
<p>xml配置文件中：</p>
<pre><code class="language-xml">&lt;delete id=&quot;deleteUserById&quot;&gt;
    delete from user where id = #{id}
&lt;/delete&gt;
</code></pre>
<h5 id="引用类型参数">引用类型参数</h5>
<p>接口中：</p>
<pre><code class="language-java">int insertUser(User user);
</code></pre>
<p>xml配置文件中：</p>
<pre><code class="language-xml">&lt;!-- 给insert语句添加useGeneratedKeys、keyProperty后，mybatis会将自增的id值直接赋值到传进来的user对象的id属性上
        useGeneratedKeys: 指定需要获取数据库自增的id
        keyProperty: 指定自增地段的名称
     --&gt;
&lt;insert id=&quot;insertUser&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
    insert into user (username,nick_name,email)
    values (#{username},#{nickName},#{email})
&lt;/insert&gt;
</code></pre>
<h5 id="当接口中参数和xml配置取值时名称不一样时">当接口中参数和XML配置取值时名称不一样时</h5>
<p>在接口中的参数前加注解</p>
<pre><code class="language-java">User queryUserById(@Param(&quot;id&quot;) Integer xxxxxxxId);
</code></pre>
<p>在XML中取值时用注解指定的名称</p>
<pre><code class="language-xml">&lt;select id=&quot;queryUserById&quot; resultType=&quot;user&quot;&gt;
    select * from user where id = #{id}
&lt;/select&gt;
</code></pre>
<h5 id="与的区别">#{}与${}的区别</h5>
<ul>
<li>它俩都可以获取接口调用中传递过来的参数</li>
<li>#{}会将参数作为占位符，使用预编译语句(PreparedStatement)执行</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow></mrow><mi mathvariant="normal">会</mi><mi mathvariant="normal">直</mi><mi mathvariant="normal">接</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">实</mi><mi mathvariant="normal">际</mi><mi mathvariant="normal">参</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">替</mi><mi mathvariant="normal">换</mi></mrow><annotation encoding="application/x-tex">{}会直接用实际参数替换</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord"></span><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">直</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">实</span><span class="mord cjk_fallback">际</span><span class="mord cjk_fallback">参</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">替</span><span class="mord cjk_fallback">换</span></span></span></span>{}， 参数可以作为SQL的一部分。</li>
</ul>
<p>比如，要实现下面的效果：</p>
<p>Java代码</p>
<pre><code class="language-java">List&lt;User&gt; queryAllUserOrderBy(String order);

// 调用：
mapper.queryAllUserOrderBy(&quot;last_login_time&quot;);
</code></pre>
<p>XML配置：</p>
<pre><code class="language-xml">&lt;select id=&quot;queryAllUserOrderBy&quot; resultMap=&quot;userMap&quot;&gt;
    select * from user order by ${order} desc;
&lt;/select&gt;
</code></pre>
<p>如果上面使用#{order}取获取参数，最终执行的SQL会是这样：</p>
<pre><code>==&gt;  Preparing: select * from user order by ? desc; 
==&gt; Parameters: last_login_time(String)
</code></pre>
<p>无法实现排序效果</p>
<p>如果使用${order}来取参数，最终执行SQL：</p>
<pre><code>==&gt;  Preparing: select * from user order by last_login_time desc; 
==&gt; Parameters: 
</code></pre>
<p>可以实现排序效果</p>
<h4 id="结果集如何映射">结果集如何映射</h4>
<h5 id="resulttype方式">ResultType方式</h5>
<p>ResultType方式适用于数据库结果集可以直接映射成一个Java类的情况</p>
<p>Java实体类：</p>
<pre><code class="language-java">@Getter
@Setter
@ToString
public class User {
    private Integer id;
    private String username;
    private String nickName;
    private String password;
    private String email;
    private Timestamp lastLoginTime;
}
</code></pre>
<p>使用方法：</p>
<pre><code class="language-xml">&lt;select id=&quot;queryAllUser&quot; resultType=&quot;com.lanou3g.bean.User&quot;&gt;
    select * from user
&lt;/select&gt;
</code></pre>
<h5 id="resultmap方式">ResultMap方式</h5>
<p>ResultMap方式适用于复杂的结果集映射，比如数据库返回的结果集中的列名和JavaBean无法一一对应，或者对象间存在一对一、一对多关联映射时。</p>
<h6 id="解决数据库列名与java类中属性名不一致的映射问题">解决数据库列名与Java类中属性名不一致的映射问题</h6>
<pre><code class="language-xml">&lt;mapper&gt;
    ...
    &lt;resultMap id=&quot;userMap&quot; type=&quot;user&quot;&gt;
        &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
        &lt;result property=&quot;username&quot; column=&quot;username&quot; /&gt;
        &lt;result property=&quot;lastLoginttime&quot; column=&quot;last_login_time&quot; /&gt;
        &lt;result property=&quot;email&quot; column=&quot;email&quot; /&gt;
        &lt;result property=&quot;nickName&quot; column=&quot;nick_name&quot; /&gt;
    &lt;/resultMap&gt;
    ...
&lt;/mapper&gt;
</code></pre>
<p>在查询语句中将resultType换成resultMap</p>
<pre><code class="language-xml">&lt;select id=&quot;queryAllUser&quot; resultMap=&quot;userMap&quot;&gt;
    select * from user
&lt;/select&gt;
</code></pre>
<blockquote>
<p>其实，如果遇到单纯字段名和属性名不对应的情况，使用别名的方式更简单</p>
</blockquote>
<h6 id="解决一对一映射查询问题">解决一对一映射查询问题</h6>
<h6 id="解决一对多映射查询问题">解决一对多映射查询问题</h6>
<h4 id="动态sql">动态SQL</h4>
<h5 id="条件分支sql">条件分支SQL</h5>
<ul>
<li>if</li>
<li>choose&amp;when&amp;otherwise</li>
</ul>
<h5 id="循环sql">循环SQL</h5>
<ul>
<li>forEach</li>
</ul>
<h5 id="其他特殊sql">其他特殊SQL</h5>
<ul>
<li>where</li>
<li>set</li>
<li>trim</li>
</ul>
<h4 id="批量插入">批量插入</h4>
<h5 id="通过foreach动态sql方式">通过forEach动态SQL方式</h5>
<h6 id="实现原理">实现原理</h6>
<p>forEach批量插入的原理是直接通过forEach动态标签，根据传过来的参数数量动态生成一个很长的SQL语句。一个语句就是一次批量插入。</p>
<p>语句形如：</p>
<pre><code class="language-sql">insert into user (username, age) values
('张三', 10),
('李四', 10),
('王五', 10),
('赵六', 10),
('盖聂', 9000)

# 上面的语句一次会插入5条数据
</code></pre>
<p>我们需要做的就是生成此语句就可以了。</p>
<h6 id="具体做法">具体做法</h6>
<p>Mapper接口</p>
<pre><code class="language-java">int batchInsertUser(List&lt;User&gt; userList);
</code></pre>
<p>Mapper映射文件</p>
<pre><code class="language-xml">&lt;insert id=&quot;batchInsertUser&quot;&gt;
	insert into user (username, age) values
    &lt;forEach collection=&quot;list&quot; item=&quot;user&quot; separator=&quot;,&quot;&gt;
    	(#{user.username}, #{user.age})
    &lt;/forEach&gt;
&lt;/insert&gt;
</code></pre>
<h5 id="通过executorbatch的方式">通过Executor.BATCH的方式</h5>
<h6 id="实现原理-2">实现原理</h6>
<p>这种批量插入在底层的Mapper接口和Mapper映射文件中，都只是一个普通插入单条数据的写法。它通过在上层获取SqlSession时，指定执行类型是批量ExcecutorType.BATCH的方式，实现每次执行完单条插入以后并没有真正写入数据库，只有当调用sqlSession.flushStatement()时，才会将这一批数据一次性写入数据库，从而实现批量操作。</p>
<h6 id="使用步骤">使用步骤</h6>
<ol>
<li>
<p>获取SqlSession时指定执行类型为批量</p>
<pre><code class="language-java">// 获取一个批量执行的sqlSession对象
SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH);
</code></pre>
</li>
<li>
<p>Mapper接口和Mapper映射文件中只需按照单条插入去写方法和SQL语句即可</p>
<p>Mapper接口</p>
<pre><code class="language-java">int insertUser(User user);
</code></pre>
<p>XML映射文件</p>
<pre><code class="language-xml">&lt;insert id=&quot;insertUser&quot;&gt;
    insert into user (nick_name, status, createtime)
    values
    (#{nickName},#{status},#{createtime})
&lt;/insert&gt;
</code></pre>
</li>
<li>
<p>空置批量的大小，在够一批数据时，调用<code>sqlSession.flushStatement()</code>去整体往数据库写一次</p>
<pre><code class="language-java">int batchSize = 100;
int count = 0;
List&lt;BatchResult&gt; resultList = new ArrayList&lt;&gt;();
for(User user : userList) {
    // ExecutorType.Batch方式这里返回的不是影响的条数，具体获取方法参见下面代码
    mapper.insertUser(user);
    count++;
    if(count % batchSize == 0) {
        resultList.addAll(sqlSession.flushStatements());
    }
}
if(count % batchSize != 0) {
    resultList.addAll(sqlSession.flushStatements());
}
</code></pre>
</li>
<li>
<p>获取影响的条数</p>
<p>这种方式获取影响条数没有那么直接，需要去API返回的BatchResult对象中读取updateCounts方法才能拿到。</p>
<pre><code class="language-java">int rows = 0;
for(BatchResult batchResult : resultList) {
    int[] updateCounts = batchResult.getUpdateCounts();
    for(int updateCount : updateCounts) {
        rows += updateCount;
    }
}
System.out.println(&quot;批量插入成功，响应的行数：&quot; + rows);
</code></pre>
</li>
</ol>
<h4 id="缓存">缓存</h4>
<h5 id="一级缓存本地缓存">一级缓存（本地缓存）</h5>
<p>Mybatis的一级缓存是指Session缓存。一级缓存的作用域默认是一个SqlSession。Mybatis默认开启一级缓存。<br>
也就是在同一个SqlSession中，执行相同的查询SQL，第一次会去数据库进行查询，并写到缓存中；<br>
第二次以后是直接去缓存中取。<br>
当执行SQL查询中间发生了增删改的操作，MyBatis会把SqlSession的缓存清空。</p>
<blockquote>
<p>问题： 如果增删改的表和缓存的表是毫不相干的两个表，是否会清空缓存？</p>
</blockquote>
<h6 id="测试方法">测试方法</h6>
<ol>
<li>我们在一个 sqlSession 中，对 User 表根据id进行两次查询，查看他们发出sql语句的情况</li>
</ol>
<pre><code class="language-java">@Test
public void testSelectOrderAndUserByOrderId(){
    //根据 sqlSessionFactory 产生 session
    SqlSession sqlSession = sessionFactory.openSession();
    String statement = &quot;one.to.one.mapper.OrdersMapper.selectOrderAndUserByOrderID&quot;;
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
    //第一次查询，发出sql语句，并将查询的结果放入缓存中
    User u1 = userMapper.selectUserByUserId(1);
    System.out.println(u1);
     
    //第二次查询，由于是同一个sqlSession,会在缓存中查找查询结果
    //如果有，则直接从缓存中取出来，不和数据库进行交互
    User u2 = userMapper.selectUserByUserId(1);
    System.out.println(u2);
     
    sqlSession.close();
}
</code></pre>
<ol start="2">
<li>同样是对user表进行两次查询，只不过两次查询之间进行了一次update操作。</li>
</ol>
<pre><code class="language-java">@Test
public void testSelectOrderAndUserByOrderId(){
    //根据 sqlSessionFactory 产生 session
    SqlSession sqlSession = sessionFactory.openSession();
    String statement = &quot;one.to.one.mapper.OrdersMapper.selectOrderAndUserByOrderID&quot;;
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
    //第一次查询，发出sql语句，并将查询的结果放入缓存中
    User u1 = userMapper.selectUserByUserId(1);
    System.out.println(u1);
     
    //第二步进行了一次更新操作，sqlSession.commit()
    u1.setSex(&quot;女&quot;);
    userMapper.updateUserByUserId(u1);
    sqlSession.commit();
     
    //第二次查询，由于是同一个sqlSession.commit(),会清空缓存信息
    //则此次查询也会发出 sql 语句
    User u2 = userMapper.selectUserByUserId(1);
    System.out.println(u2);
     
    sqlSession.close();
}
</code></pre>
<h5 id="如何禁用一级缓存">如何禁用一级缓存</h5>
<ul>
<li>在映射文件中给对应的select标签上添加<code>flushCache=&quot;true&quot;</code>属性</li>
<li>在核心配置文件中将localCacheScope设置成STATEMENT（默认值是SESSION）</li>
</ul>
<h5 id="二级缓存全局缓存">二级缓存（全局缓存）</h5>
<h6 id="什么是二级缓存">什么是二级缓存？</h6>
<p>Mybatis中二级缓存相比一级（本地）缓存来说是一个作用域更大的缓存方案。 二级缓存的作用域可以跨多个SqlSession，只要是同一个namespace下的mapper映射文件都可以共享缓存。但是不能跨SqlSessionFactory。</p>
<p>Mybatis二级缓存需要手动开启。</p>
<h6 id="开启二级缓存的方法">开启二级缓存的方法</h6>
<p>1.在 SqlMapConfig.xml 文件开启二级缓存</p>
<pre><code class="language-xml">&lt;settings&gt; 
    &lt;!-- 开启全局二级缓存的支持 --&gt;  
    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; 
&lt;/settings&gt; 
</code></pre>
<p>2.配置相关的 Mapper 映射文件 (因为二级缓存就是针对特定的mapper namespace的)</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; 
&lt;!DOCTYPE mapper     
PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;     
&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; 
&lt;mapper namespace=&quot;com.itheima.dao.IUserDao&quot;&gt;  
    &lt;!-- 开启二级缓存的支持 --&gt;  
    &lt;cache /&gt;
&lt;/mapper&gt;
</code></pre>
<blockquote>
<p><cache>标签表示当前这个 mapper 映射将使用二级缓存，能否命中二级缓存就看多次查询是否属于同一个namespace。</p>
</blockquote>
<ol start="3">
<li>设置某个特定的查询语句不用二级缓存</li>
</ol>
<pre><code class="language-xml">&lt;!-- 根据 id 查询 --&gt; 
&lt;select id=&quot;findById&quot; resultType=&quot;user&quot; parameterType=&quot;int&quot; useCache=&quot;false&quot;&gt;  
    select * from user where id = #{uid} 
&lt;/select&gt; 
</code></pre>
<blockquote>
<p>注意： 如果mapper文件中没有开启 <cache /> 仅在语句上添加useCache=&quot;true&quot;是无法开启二级缓存的。这个属性本意是用来关闭特定查询的二级缓存。</p>
</blockquote>
<h6 id="二级缓存注意事项">二级缓存注意事项</h6>
<blockquote>
<p>当我们在使用二级缓存时，所缓存的类一定要实现 java.io.Serializable 接口，这种就可以使用序列化 方式来保存对象。</p>
</blockquote>
<pre><code class="language-java">public class User implements Serializable { }
</code></pre>
<h4 id="mybatis逆向工程">Mybatis逆向工程</h4>
<h2 id="spring与mybatis整合">Spring与Mybatis整合</h2>
<ol>
<li>
<p>加入依赖</p>
<pre><code class="language-xml">&lt;!-- mybatis-spring整合依赖，这个是最主要的一个依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
    &lt;version&gt;2.0.1&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- Spring和数据源相关依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid&lt;/artifactId&gt;
    &lt;version&gt;1.1.20&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>在Spring bean配置文件中配置Mybatis、Spring整合bean  SqlSessionFactoryBean</p>
<pre><code class="language-xml">&lt;!-- 配置整合bean --&gt;
&lt;bean id=&quot;sessionFactoryBean&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
    &lt;!-- 数据源是必要参数 --&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
    &lt;!-- Mybatis核心配置文件其实大多数情况下都可以省略，通过指定属性可以间接设置核心配置文件中的参数 --&gt;
    &lt;!--&lt;property name=&quot;configLocation&quot; value=&quot;mybatis_conf.xml&quot; /&gt;--&gt;

    &lt;!-- 省略mybatis核心配置文件后，可以通过类似下面这些特定属性，设置mybatis参数 --&gt;
    &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.lanou3g.mybatis.spring.bean&quot; /&gt;
    &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot; /&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>在Spring bean配置文件中开启Mybatis Mapper扫描</p>
<ol>
<li>
<p>需要使用mybatis schema</p>
<p>配置方法，在bean配置文件的头部添加</p>
<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mybatis=&quot;http://mybatis.org/schema/mybatis-spring&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd
        http://mybatis.org/schema/mybatis-spring
        http://mybatis.org/schema/mybatis-spring.xsd&quot;&gt;
</code></pre>
</li>
<li>
<p>开启Mybatis Mapper扫描</p>
<p>开启Mybatis Mapper扫描的作用是：告诉Mybatis要创建哪个包下接口的实现类，并以bean的方式加入到SpringIOC容器中</p>
<pre><code class="language-xml">&lt;!-- 开启Mapper扫描，Mybatis会创建将此包下的接口的实现类，并以bean的方式加入到SpringIOC容器中 --&gt;
&lt;mybatis:scan base-package=&quot;com.lanou3g.mybatis.spring.mapper&quot; /&gt;
</code></pre>
</li>
</ol>
</li>
<li>
<p>创建实体类、mapper映射文件、Mapper接口（可以通过Mybatis逆向工程直接生成）</p>
<p>Mapper接口</p>
<pre><code class="language-java">@Repository	//此注解不是必须的，因为MessageMapper类的实现类是由Mybatis创建并放到ioc容器中的，不是由Spring来创建的。
public interface MessageMapper {
    int insert(Message record);
    List&lt;Message&gt; selectAll();
}
</code></pre>
<p>实体类、映射文件 略</p>
</li>
<li>
<p>将Mapper接口用Spring自动注入的方式注入到需要的地方使用</p>
<p>MessageService.java</p>
<pre><code class="language-java">@Service
public class MessageService {
    @Autowired
    MessageMapper messageMapper;
    public List&lt;Message&gt; queryAllMessage() {
        return messageMapper.selectAll();
    }
}
</code></pre>
</li>
</ol>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#mybatis%E4%BB%8B%E7%BB%8D">Mybatis介绍</a></li>
<li><a href="#mybatis%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8">Mybatis简单使用</a></li>
<li><a href="#%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3mybatis">深入了解Mybatis</a>
<ul>
<li><a href="#%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6">主要组件</a>
<ul>
<li><a href="#%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">核心配置文件</a></li>
<li><a href="#sqlsessionfactory">SqlSessionFactory</a></li>
<li><a href="#sqlsession">SqlSession</a></li>
<li><a href="#mapper">Mapper</a></li>
</ul>
</li>
<li><a href="#%E6%B7%B1%E5%85%A5mybatis%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">深入Mybatis核心配置文件</a></li>
<li><a href="#%E6%B7%B1%E5%85%A5mybatis%E6%98%A0%E5%B0%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">深入Mybatis映射配置文件</a>
<ul>
<li><a href="#crud%E8%AF%AD%E5%8F%A5%E5%AE%9A%E4%B9%89">CRUD语句定义</a>
<ul>
<li><a href="#%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5">查询语句</a></li>
<li><a href="#%E6%8F%92%E5%85%A5%E8%AF%AD%E5%8F%A5">插入语句</a>
<ul>
<li><a href="#%E6%99%AE%E9%80%9A%E6%8F%92%E5%85%A5%E8%AF%AD%E5%8F%A5">普通插入语句</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%AA%E5%A2%9E%E7%9A%84id">如何返回数据库自增的ID</a></li>
</ul>
</li>
<li><a href="#%E5%88%A0%E9%99%A4%E8%AF%AD%E5%8F%A5">删除语句</a></li>
<li><a href="#%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5">更新语句</a></li>
</ul>
</li>
<li><a href="#%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E5%A6%82%E6%9E%9C%E4%BC%A0%E9%80%92%E5%88%B0sql%E4%B8%AD">接口中的参数如果传递到SQL中</a>
<ul>
<li><a href="#%E7%AE%80%E5%8D%95%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0">简单类型参数</a></li>
<li><a href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0">引用类型参数</a></li>
<li><a href="#%E5%BD%93%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%8F%82%E6%95%B0%E5%92%8Cxml%E9%85%8D%E7%BD%AE%E5%8F%96%E5%80%BC%E6%97%B6%E5%90%8D%E7%A7%B0%E4%B8%8D%E4%B8%80%E6%A0%B7%E6%97%B6">当接口中参数和XML配置取值时名称不一样时</a></li>
<li><a href="#%E4%B8%8E%E7%9A%84%E5%8C%BA%E5%88%AB">#{}与${}的区别</a></li>
</ul>
</li>
<li><a href="#%E7%BB%93%E6%9E%9C%E9%9B%86%E5%A6%82%E4%BD%95%E6%98%A0%E5%B0%84">结果集如何映射</a>
<ul>
<li><a href="#resulttype%E6%96%B9%E5%BC%8F">ResultType方式</a></li>
<li><a href="#resultmap%E6%96%B9%E5%BC%8F">ResultMap方式</a>
<ul>
<li><a href="#%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%97%E5%90%8D%E4%B8%8Ejava%E7%B1%BB%E4%B8%AD%E5%B1%9E%E6%80%A7%E5%90%8D%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84%E6%98%A0%E5%B0%84%E9%97%AE%E9%A2%98">解决数据库列名与Java类中属性名不一致的映射问题</a></li>
<li><a href="#%E8%A7%A3%E5%86%B3%E4%B8%80%E5%AF%B9%E4%B8%80%E6%98%A0%E5%B0%84%E6%9F%A5%E8%AF%A2%E9%97%AE%E9%A2%98">解决一对一映射查询问题</a></li>
<li><a href="#%E8%A7%A3%E5%86%B3%E4%B8%80%E5%AF%B9%E5%A4%9A%E6%98%A0%E5%B0%84%E6%9F%A5%E8%AF%A2%E9%97%AE%E9%A2%98">解决一对多映射查询问题</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%8A%A8%E6%80%81sql">动态SQL</a>
<ul>
<li><a href="#%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AFsql">条件分支SQL</a></li>
<li><a href="#%E5%BE%AA%E7%8E%AFsql">循环SQL</a></li>
<li><a href="#%E5%85%B6%E4%BB%96%E7%89%B9%E6%AE%8Asql">其他特殊SQL</a></li>
</ul>
</li>
<li><a href="#%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5">批量插入</a>
<ul>
<li><a href="#%E9%80%9A%E8%BF%87foreach%E5%8A%A8%E6%80%81sql%E6%96%B9%E5%BC%8F">通过forEach动态SQL方式</a>
<ul>
<li><a href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">实现原理</a></li>
<li><a href="#%E5%85%B7%E4%BD%93%E5%81%9A%E6%B3%95">具体做法</a></li>
</ul>
</li>
<li><a href="#%E9%80%9A%E8%BF%87executorbatch%E7%9A%84%E6%96%B9%E5%BC%8F">通过Executor.BATCH的方式</a>
<ul>
<li><a href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-2">实现原理</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4">使用步骤</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%BC%93%E5%AD%98">缓存</a>
<ul>
<li><a href="#%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98">一级缓存（本地缓存）</a>
<ul>
<li><a href="#%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95">测试方法</a></li>
</ul>
</li>
<li><a href="#%E5%A6%82%E4%BD%95%E7%A6%81%E7%94%A8%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98">如何禁用一级缓存</a></li>
<li><a href="#%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E5%85%A8%E5%B1%80%E7%BC%93%E5%AD%98">二级缓存（全局缓存）</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98">什么是二级缓存？</a></li>
<li><a href="#%E5%BC%80%E5%90%AF%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E6%96%B9%E6%B3%95">开启二级缓存的方法</a></li>
<li><a href="#%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">二级缓存注意事项</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#mybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B">Mybatis逆向工程</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#spring%E4%B8%8Emybatis%E6%95%B4%E5%90%88">Spring与Mybatis整合</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://zjt-zjt.github.io/post/springmvc-xue-xi-bi-ji">
              <h3 class="post-title">
                SpringMVC
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://zjt-zjt.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()

  let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

  // This should probably be throttled.
  // Especially because it triggers during smooth scrolling.
  // https://lodash.com/docs/4.17.10#throttle
  // You could do like...
  // window.addEventListener("scroll", () => {
  //    _.throttle(doThatStuff, 100);
  // });
  // Only not doing it here to keep this Pen dependency-free.

  window.addEventListener("scroll", event => {
    let fromTop = window.scrollY;

    mainNavLinks.forEach((link, index) => {
      let section = document.getElementById(decodeURI(link.hash).substring(1));
      let nextSection = null
      if (mainNavLinks[index + 1]) {
        nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
      }
      if (section.offsetTop <= fromTop) {
        if (nextSection) {
          if (nextSection.offsetTop > fromTop) {
            link.classList.add("current");
          } else {
            link.classList.remove("current");    
          }
        } else {
          link.classList.add("current");
        }
      } else {
        link.classList.remove("current");
      }
    });
  });

</script>

      </div>
    </div>
  </body>
</html>
