<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Spring | Gridea</title>
<meta name="description" content="温故而知新" />
<link rel="shortcut icon" href="https://zjt-zjt.github.io/favicon.ico?v=1576062450996">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://zjt-zjt.github.io/styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://zjt-zjt.github.io">
  <img class="avatar" src="https://zjt-zjt.github.io/images/avatar.png?v=1576062450996" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Spring
            </h2>
            <div class="post-info">
              <span>
                2018-09-04
              </span>
              <span>
                38 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <!-- more -->
<h2 id="ioc容器概念">IOC容器概念</h2>
<p>IOC其实就是一个对象的容器。全称Inversion Of Control 控制反转，核心的作用就是将原来由开发人员来控制的对象管理操作交由Spring来管理。</p>
<p>SpringIOC不仅帮我们管理了对象的创建，还包括给对象增加了生命周期行为、作用域(单例、非单例)、懒加载。 配合Spring的DI， 更能方便的解决对象属性值注入、对象之间的依赖注入问题。</p>
<h2 id="ioc容器初始化方式">IOC容器初始化方式</h2>
<h3 id="classpathxmlapplicationcontext">ClassPathXmlApplicationContext</h3>
<p>该类负责加载类路径下的xml配置文件的方式，去初始化IOC容器上下文，具体使用步骤如下：</p>
<ol>
<li>
<p>编写配置文件</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    
    &lt;!-- 使用bean标签将对象配置到ioc容器中 --&gt;
    &lt;bean id=&quot;man&quot; class=&quot;com.lanou3g.bean.Man&quot; /&gt;
    &lt;bean id=&quot;apple&quot; class=&quot;com.lanou3g.bean.Food&quot; /&gt;
&lt;/beans&gt;
</code></pre>
</li>
<li>
<p>加载配置文件，初始化IOC容器</p>
</li>
</ol>
<pre><code class="language-java">   // 加载单个xml配置，初始化上下文
   ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext1.xml&quot;);
  
   // 加载多个xml配置，初始化上下文
   ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(new String[]{&quot;applicationContext1.xml&quot;, &quot;applicationContext2.xml&quot;});
  
   // 加载当前运行类所在的类路径下所有以application开头的配置文件
   ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;appliction*.xml&quot;);
  
   // 加载工程中所有类路径下所有以application开头的配置文件
   ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath*:appliction*.xml&quot;);
  
   // 加载工程中所有类路径下所有以application或spring开头的配置文件
   ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(new String[]{&quot;classpath*:appliction*.xml&quot;, &quot;classpath*:spring*.xml&quot;});
</code></pre>
<blockquote>
<p>配置文件路径中可以包含通配符(*)和前缀(classpath*:，代表所有类路径，包括源码类路径和单元测试类路径)</p>
</blockquote>
<ol start="3">
<li>
<p>从容器中获取对象</p>
<pre><code class="language-java">// 通过xml中配置的bean的id或name属性的值获取bean, 返回的类型是Object，需要强转成对象真正的类型
Man man = (Man) cxt.getBean(&quot;man&quot;); 
// 通过bean的名称获取bean的同时，指定类型 
Man man1 = cxt.getBean(&quot;man&quot;,Man.class); 
// 通过类型从容器中获取bean，如果容器中该类型的bean有多于一个，则会报错
Man man2 = cxt.getBean(Man.class); 

// 调用对象的方法
man.eat();
man.play();
</code></pre>
</li>
</ol>
<h3 id="annotationconfigapplicationcontext">AnnotationConfigApplicationContext</h3>
<p>加载通过Java注解方式配置的Bean上下文。具体使用步骤如下：</p>
<ol>
<li>
<p>定义配置类</p>
<pre><code class="language-java">@Configuration	//代表该类是一个bean的配置类，类似于xml配置中的&lt;beans&gt;标签
public class MyConfiguration {

}
</code></pre>
<ol>
<li>
<p>开启注解支持，配置扫描包路径</p>
<p>如果是通过ClassPathXmlApplicationContext初始化的上下文，则在xml中添加如下配置：</p>
<pre><code class="language-xml">&lt;!-- 添加context命名空间 --&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

&lt;!-- 下面两个配置用于xml和注解配置混合使用时，开启注解扫描支持，并指定扫描的包路径 --&gt;
&lt;!-- 如果指定了扫描包路径，该配置可省略 --&gt;
&lt;context:annotation-config /&gt; 
&lt;context:component-scan base-package=&quot;com.lanou3g.spring&quot; /&gt;
</code></pre>
<p>如果是通过AnnotationConfigApplicationContext初始化的上下文，则需要在t通过<code>@Configuration</code>注解标注的配置类上添加 @ComponentScans注解：</p>
<pre><code class="language-java">@Configuration
@ComponentScan(basePackages = &quot;com.lanou.spring&quot;) //指定扫描包路径
public class MyConfiguration {

}
</code></pre>
</li>
<li>
<p>配置Bean</p>
<p>通过注解方式有两种方式可以将类的对象交由IOC容器中管理</p>
<ul>
<li>
<p>通过@Component的方式定义</p>
<pre><code class="language-java">@Component
public class King {
}
</code></pre>
<blockquote>
<p>适用于我们自己定义的类，或者我们可以修改源代码的类</p>
</blockquote>
</li>
<li>
<p>通过@Bean注解定义</p>
<pre><code class="language-java">public class King {
}


@Configuration
public class MyApplicationContextConf {
    @Bean
    public King king() {
        return new King();
    }
}
</code></pre>
<blockquote>
<p>适用于需要将第三方jar包中的类交由ioc管理，因为我们不能修改jar包中的代码，无法给其添加@Component注解</p>
</blockquote>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p>加载配置类，初始化IOC容器</p>
<pre><code class="language-java">// 加载单个注解配置，初始化上下文
AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(MyConfiguration.class);

// 加载多个注解配置，初始化上下文
AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(new Class[]{MyConfiguration1.class, MyConfiguration2.class});
</code></pre>
</li>
<li>
<p>从容器中获取bean</p>
<pre><code class="language-java">// 通过xml中配置的bean的id或name属性的值获取bean, 返回的类型是Object，需要强转成对象真正的类型
Man man = (Man) cxt.getBean(&quot;man&quot;); 
// 通过bean的名称获取bean的同时，指定类型 
Man man1 = cxt.getBean(&quot;man&quot;,Man.class); 
// 通过类型从容器中获取bean，如果容器中该类型的bean有多于一个，则会报错
Man man2 = cxt.getBean(Man.class); 

// 调用对象的方法
man.eat();
man.play();
</code></pre>
</li>
</ol>
<h2 id="bean初始化方式">Bean初始化方式</h2>
<h3 id="构造方法方式最常用">构造方法方式（最常用）</h3>
<pre><code class="language-xml">&lt;bean id=&quot;xx&quot; class=&quot;com.test.StudentDao&quot; /&gt;
</code></pre>
<h3 id="静态工厂方法">静态工厂方法</h3>
<pre><code class="language-xml">&lt;!-- 
	class：指定的是静态工厂类，而不是将要创建的对象类型
	factory-method: 指定的是工厂中的静态方法 
--&gt;
&lt;bean id=&quot;xx&quot; class=&quot;com.test.StudentDaoFactory&quot; factory-method=&quot;createDao&quot; /&gt;
</code></pre>
<h3 id="实例工厂方法">实例工厂方法</h3>
<pre><code class="language-xml">&lt;!-- 
	class：指定的是实例工厂类 
--&gt;
&lt;bean id=&quot;xxFactory&quot; class=&quot;com.test.StudentDaoFactory&quot; /&gt;
&lt;!-- 
	factory-bean：指定的是实例工厂对象
	factory-method: 指定的是工厂中的实例方法 
--&gt;
&lt;bean id=&quot;xx&quot; factory-bean=&quot;xxFactory&quot; factory-method=&quot;createDao&quot; /&gt;
</code></pre>
<h2 id="bean的命名">Bean的命名</h2>
<p>在XML中配置中可以通过<bean>标签上的id、name属性值给一个bean命名，以便在其他地方引用。</p>
<p>id属性： bean的唯一名称，只允许出现一个值。且同一个IOC容器中不允许出现两个id值一样的bean。</p>
<p>name属性： 和id类似也是给bean命名。但是name属性的值可以有多个，多个值之间使用英文逗号(,)或者英文分号(;)或者空格符隔开</p>
<h2 id="bean的作用域">Bean的作用域</h2>
<ul>
<li>
<p>prototype</p>
<p>在SpringIOC中prototype scope的意思指的是非单例，就是每次使用该bean的时候都会重新创建一个对象。</p>
<figure data-type="image" tabindex="1"><img src="https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/images/prototype.png" alt="原型作用域示意图"></figure>
</li>
<li>
<p>singleton(默认)</p>
<p>singleton作用域是IOC中默认的作用域，代表单例。每次使用bean的时候，不会重新创建对象，在整个IOC容器中该类型的对象只有一个。</p>
<figure data-type="image" tabindex="2"><img src="https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/images/singleton.png" alt="单例作用域示意图"></figure>
</li>
</ul>
<h2 id="bean的生命周期">Bean的生命周期</h2>
<ul>
<li>Singleton Bean的生命周期
<ul>
<li>初始化时机： 在IOC容器初始化时，就会把配置的所有单例bean实例化。</li>
<li>销毁时机：在IOC容器销毁时，所有bean的销毁方法会被调用。</li>
</ul>
</li>
<li>Prototype Bean的生命周期
<ul>
<li>初始化时机： 在实际使用该bean的时候，比如：getBean、获取依赖此bean的其他bean需要使用</li>
<li>销毁时机： 在IOC容器销毁时。（但是通过destroy-method指定的声明周期方法不会被调用，也就是说Spring不提供prototypebean完整的生命周期管理）</li>
</ul>
</li>
<li>如何指定生命周期的回调方法
<ul>
<li>xml中的init-method、destroy-method</li>
<li>注解方式@PostConstrutor、@PreDestroy</li>
</ul>
</li>
<li>指定默认的声明周期回调方法
<ul>
<li>在xml中，通过在beans标签上添加default-init-method、default-destory-method来指定</li>
<li>在注解配置中，没有对应的方法可以设置所有bean默认的生命周期回调</li>
</ul>
</li>
</ul>
<h2 id="bean懒加载">Bean懒加载</h2>
<p>lazy-init属性</p>
<p>默认是false</p>
<blockquote>
<p>懒加载配置主要是针对单例的bean，因为它默认是在容器初始化时就被实例化了。</p>
</blockquote>
<h2 id="如何优雅的停止非web-spring应用">如何优雅的停止非Web Spring应用</h2>
<p>添加一个shutdown hook。所有派生自ConfigurableApplicationContext接口的实现类都支持此方法</p>
<pre><code class="language-java">ConfigurableApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;xxx.xml&quot;);

ctx.registerShutdownHook(); //注册停止回调
</code></pre>
<h1 id="spring-di">Spring DI</h1>
<h2 id="概述">概述</h2>
<p>DI的全称是Dependency Injection（依赖注入）。IOC是将我们工程中的所有对象交由Spring来管理，DI是此基础，将对象中的属性、依赖的其他对象也管理起来，自动注入到由Spring帮我们管理的对象中。</p>
<blockquote>
<p>将要注入的对象和目标对象都必须是由SpringIOC管理的bean.</p>
</blockquote>
<h2 id="di的细节实现">DI的细节实现</h2>
<h3 id="构造参数注入">构造参数注入</h3>
<p>将一个bean创建过程中构造方法需要的参数，通过Spring DI的方式，自动注入到构造方法中。</p>
<h3 id="setter注入">Setter注入</h3>
<p>先通过一个无参的构造方法创建对象，然后通过属性的setter方法，将属性值注入到对象上。</p>
<h3 id="支持注入的类型">支持注入的类型</h3>
<ul>
<li>
<p>普通字面量</p>
<ul>
<li>String</li>
<li>Integer(int)</li>
<li>Long(long)</li>
<li>Byte(byte)</li>
<li>...</li>
</ul>
</li>
<li>
<p>集和类型</p>
<ul>
<li>
<p>List</p>
<pre><code class="language-xml">&lt;bean id=&quot;xxx&quot; class=&quot;xx.xxx.xxx.AA&quot;&gt;&lt;/bean&gt;
&lt;bean&gt;
    &lt;property name=&quot;hobbies&quot;&gt;
    	&lt;list&gt;
        	&lt;value&gt;简单类型值&lt;/value&gt;
            &lt;bean&gt;内部bean&lt;/bean&gt;
            &lt;ref bean=&quot;xxx&quot; /&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>Map</p>
<pre><code class="language-xml">&lt;bean id=&quot;xxx&quot; class=&quot;xx.xxx.xxx.AA&quot;&gt;&lt;/bean&gt;
&lt;bean&gt;
    &lt;property name=&quot;gameTitle&quot;&gt;
    	&lt;map&gt;
        	&lt;entry key=&quot;王者荣耀&quot; value=&quot;荣耀王者&quot; /&gt;
            &lt;entry key=&quot;王者荣耀&quot; value-ref=&quot;xxx&quot; /&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>Set</p>
<pre><code class="language-xml">&lt;bean id=&quot;xxx&quot; class=&quot;xx.xxx.xxx.AA&quot;&gt;&lt;/bean&gt;
&lt;bean&gt;
    &lt;property name=&quot;hobbies&quot;&gt;
    	&lt;!-- set用法和List类似， 里面可以注入普通字面量值、也可以是一个bean引用，或者内部bean、或者是一个set、list、Properties  --&gt;
        &lt;set&gt;
        	&lt;value&gt;简单类型值&lt;/value&gt;
            &lt;bean&gt;内部bean&lt;/bean&gt;
            &lt;ref bean=&quot;xxx&quot; /&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>java.util.Properties</p>
<pre><code class="language-xml">&lt;!-- props标签是用来注入java.util.Properties类型的属性，用法和map类似，但是属性值是在标签中间写 --&gt;
&lt;property name=&quot;gameNick&quot;&gt;
    &lt;props&gt;
        &lt;prop key=&quot;王者荣耀&quot;&gt;最擅长1V5&lt;/prop&gt;
        &lt;prop key=&quot;吃鸡&quot;&gt;一枪爆头&lt;/prop&gt;
    &lt;/props&gt;
&lt;/property&gt;
</code></pre>
</li>
<li>
<p>注入空置、空字符串</p>
<pre><code class="language-xml">&lt;property name=&quot;gameNick&quot;&gt;
    &lt;null /&gt;
&lt;/property&gt;


&lt;property name=&quot;gameNick&quot; value=&quot;&quot; /&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="自动装配">自动装配</h3>
<h5 id="自动装配支持的策略">自动装配支持的策略</h5>
<ul>
<li>
<p>byType</p>
<p>按照类型去IOC容器中找需要的bean，如果找到一个，则自动装配；如果没找到，不注入此属性；如果找到了多个匹配类型的bean，就会报错。</p>
</li>
<li>
<p>byName</p>
<p>按照名称去IOC容器中找需要的bean，如果找到就自动注入；如果没找到，不注入此属性。</p>
</li>
<li>
<p>constructor</p>
<p>工作原理和byType类似，也是按照类型去IOC容器中找对应的bean。不同的是注入的地方不是setter，而是构造方法的参数。</p>
</li>
<li>
<p>no  （默认值）</p>
<p>如果没有打开自动注入，默认Spring不会自动装配需要的属性。</p>
</li>
</ul>
<h2 id="xml方式的di">XML方式的DI</h2>
<h3 id="构造参数注入-2">构造参数注入</h3>
<ul>
<li>
<p>常规写法</p>
<pre><code class="language-xml">&lt;bean id=&quot;xx&quot; class=&quot;&quot; /&gt;
&lt;bean class=&quot;com.test.XXX&quot;&gt;
	&lt;constructor-arg name=&quot;age&quot; value=&quot;45&quot; /&gt;
    &lt;constructor-arg name=&quot;x&quot; ref=&quot;xx&quot; /&gt;  &lt;!-- 注入引用的bean --&gt;
    &lt;constructor-arg name=&quot;&quot;&gt;	&lt;!-- 注入内部bean --&gt;
    	&lt;bean&gt;&lt;/bean&gt;
    &lt;/constructor-arg&gt;
    &lt;constructor-arg name=&quot;&quot;&gt;	&lt;!-- 注入list类型构造参数 --&gt;
    	&lt;list&gt;
        	
        &lt;/list&gt;
    &lt;/constructor-arg&gt;
    ....
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>c命名空间简写</p>
<pre><code class="language-xml">&lt;bean id=&quot;xx&quot; class=&quot;&quot; /&gt;
&lt;bean class=&quot;com.test.XXX&quot; c:age=&quot;45&quot; c:x-ref=&quot;xx&quot; /&gt;
</code></pre>
</li>
</ul>
<h3 id="setter方式注入">setter方式注入</h3>
<p>setter注入能够注入的类型以及写法基本和构造参数注入时的写法一致，只不过将<construtor-arg>标签换成了<property></p>
<ul>
<li>
<p>常规用法</p>
<pre><code class="language-xml">&lt;bean id=&quot;xx&quot; class=&quot;&quot; /&gt;
&lt;bean class=&quot;com.test.XXX&quot;&gt;
	&lt;property name=&quot;age&quot; value=&quot;45&quot; /&gt;
    &lt;property name=&quot;x&quot; ref=&quot;xx&quot; /&gt;  &lt;!-- 注入引用的bean --&gt;
    &lt;property name=&quot;&quot;&gt;	&lt;!-- 注入内部bean --&gt;
    	&lt;bean&gt;&lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name=&quot;&quot;&gt;	&lt;!-- 注入list类型构造参数 --&gt;
    	&lt;list&gt;
        	
        &lt;/list&gt;
    &lt;/property&gt;
    ....
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>p命名空间简写</p>
<pre><code class="language-xml">&lt;bean id=&quot;xx&quot; class=&quot;&quot; /&gt;
&lt;bean class=&quot;com.test.XXX&quot; p:age=&quot;45&quot; p:x-ref=&quot;xx&quot; /&gt;
</code></pre>
</li>
</ul>
<h3 id="开启自动装配">开启自动装配</h3>
<pre><code class="language-xml">&lt;!-- 
通过给当前的bean添加autowire属性开启自动注入
可选的值：参见自动装配章节
 --&gt;
&lt;bean id=&quot;xx&quot; class=&quot;&quot; autowire=&quot;&quot; /&gt;
</code></pre>
<h3 id="提高自动装配时的权重">提高自动装配时的权重</h3>
<pre><code class="language-xml">&lt;!-- 当其他的bean中需要注入一个Test类型的属性，而满足条件的bean有多个时，会优先注入primary=&quot;true&quot;的bean --&gt;
&lt;bean id=&quot;xx&quot; class=&quot;com.Test&quot; primary=&quot;true&quot; /&gt;
</code></pre>
<h3 id="按类型自动装配时不参与候选">按类型自动装配时，不参与候选</h3>
<pre><code class="language-xml">&lt;!-- 当其他的bean中需要注入一个Test类型的属性，而满足条件的bean有多个时，autowire-candidate=&quot;false&quot;的bean会自动退出候选序列 --&gt;
&lt;bean id=&quot;xx&quot; class=&quot;com.Test&quot; autowire-candidate=&quot;false&quot; /&gt;
</code></pre>
<h2 id="注解方式的di">注解方式的DI</h2>
<ul>
<li>
<p>构造参数注入</p>
<p>在构造方法上添加 <code>@Autowired</code>注解，构造方法的参数就会自动注入进来</p>
</li>
<li>
<p>setter方法注入</p>
<p>方法有两种：</p>
<ol>
<li>在属性的setter方法上添加<code>@Autowired</code>注解</li>
<li>在属性上添加<code>@Autowired</code>注解</li>
</ol>
</li>
</ul>
<h3 id="提高自动装配时的权重-2">提高自动装配时的权重</h3>
<pre><code class="language-java">@Primary
@Component
public class Test {


}

public class Main {
    
    @Primary
    @Bean
    public void test() {
        return new Test();
    }
    
}
</code></pre>
<h2 id="注入外部property文件中的属性值">注入外部Property文件中的属性值</h2>
<h3 id="在xml中的配置方式">在XML中的配置方式</h3>
<pre><code class="language-xml">&lt;!-- 添加context命名空间 --&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;


&lt;!-- 导入外部properties文件到ioc上下文中 --&gt;
&lt;context:property-placeholder location=&quot;jdbc.properties&quot; /&gt;

&lt;!-- 使用占位符的方式获取properties文件中的属性值 --&gt;
&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt;
    &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;
    &lt;property name=&quot;username&quot; value=&quot;${jdbc.user}&quot; /&gt;
    &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="在注解中的配置方式">在注解中的配置方式</h3>
<p>通过<code>@PropertySource</code>注解可以将外部properties文件导入到上下文中，通过<code>@Value</code>注解可以获取properties文件中的属性值，并注入到当前类的属性中</p>
<pre><code class="language-java">@Configuration
@ComponentScan(basePackages = &quot;com.lanou.spring&quot;)
@PropertySource(&quot;classpath:/jdbc.properties&quot;)
public class MyConfiguration {

	@Value(&quot;${jdbc.url}&quot;)
    private String url;
    @Value(&quot;${jdbc.user}&quot;)
    private String username;
    @Value(&quot;${jdbc.password}&quot;)
    private String password;
    @Value(&quot;${jdbc.driver}&quot;)
    private String driverClassName;
}
</code></pre>
<h1 id="springaop">SpringAOP</h1>
<h2 id="概述-2">概述</h2>
<p>AOP的全称是Aspect Oriented  Programming(面向切面编程)</p>
<p>OOP语言提供了类与类之间纵向的关系（继承、接口），而AOP补充了横向的关系（比如在不改变目标类中源代码的情况下给com.john.demo.dao包下所有类中以insert和update开头的方法添加事务管理）</p>
<h3 id="springaop和aspectj的区别">SpringAOP和AspectJ的区别</h3>
<p>AspectJ是一个专门主打面向切面编程的框架。 它是使用一种特殊的语言(扩展自Java语言)来编写切面代码，后缀是.aj格式，并且需要使用专门的编译器将其编译成jvm可以运行的class文件。</p>
<p>SpringAOP底层也是使用了AspectJ的方案，但是在上层做了很多封装层面的工作，可以让开发人员直接使用Java代码来编写切面。并且由于使用的是标准的Java语言，所以并不需要在额外安装一个专门的编译器。但是由于开发人员直接接触的是Spring AOP，那么凡是Spring中没有实现的那些AOP功能，我们就用不了了，这种情况下只能跟产品经理撕逼或者去学习原生的AspectJ。</p>
<h2 id="aop的术语">AOP的术语</h2>
<ul>
<li>
<p>切面（Aspect）</p>
<p>简单来说，切面就是我们要往目标代码中插入进去的代码。</p>
</li>
<li>
<p>连接点（Join Pointer）</p>
<p>理论上所有可能会被切入的地方都可以称之为连接点</p>
</li>
<li>
<p>切入点(Pointcut)</p>
<p>选择某个连接点切入，将切面代码织入进去。这个连接点就叫做切入点。</p>
</li>
<li>
<p>织入(Weaving)</p>
<p>把切面代码糅合到目标代码中的过程就是织入。</p>
</li>
<li>
<p>通知(Advice)</p>
<p>通知决定了切面代码织入到目标代码中后，运行的时机(比如是在目标方法执行前，还是执行后)。</p>
</li>
</ul>
<h2 id="在spring中使用aop">在Spring中使用AOP</h2>
<h3 id="基于xml方式使用">基于XML方式使用</h3>
<ol>
<li>
<p>把aop的schema引入</p>
<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
</code></pre>
</li>
<li>
<p>创建一个切面类，并且以bean的方式配置到IOC容器中</p>
<pre><code class="language-java">package com.lanou3g.spring;
public class MyAspect {

    public void wakeup() {
        System.out.println(&quot;[前置通知]我刚学习SpringAOP睡着了，刚才谁打了我一下？&quot;);
    }


    public void goToBed() {
        System.out.println(&quot;[后置通知]SpringAOP太难了，一不小心又睡着了&quot;);
    }


    public void afterRetuing(Object message) {
        System.out.println(&quot;[后置返回通知]方法执行已经return了，方法返回值是：&quot; + message);
    }

    public void afterThrowing(Throwable ex) {
        System.out.println(&quot;[后置异常通知]方法执行出现异常，异常原因：&quot; + ex.getMessage());
    }

    /**
     * 环绕通知
     * 可以接受一个ProceedingJoinPoint参数
     *      通过此参数可以获取到被切入方法的所有信息
     *      还可以通过此参数来决定是否调用目标方法
     */
    public void aroundAdvice(ProceedingJoinPoint joinPoint) {

        // 连接点参数可以获取到被切入方法的所有信息
        // 这里演示了如何获取被切入方法的名称
        String targetMethodName = joinPoint.getSignature().getName();
        System.out.println(&quot;[环绕通知]被切入的方法名：&quot; + targetMethodName);

        //
        System.out.println(&quot;[环绕通知]即将开始新的一天， 早起的鸟儿有虫吃！&quot;);
        try {
            joinPoint.proceed();
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
        System.out.println(&quot;[环绕通知]这真是充实的一天， 早睡早起，方能养生！&quot;);
    }
}
</code></pre>
<pre><code class="language-xml">&lt;bean id=&quot;myAspect&quot; class=&quot;com.lanou3g.spring.MyAspect&quot; /&gt;
</code></pre>
</li>
<li>
<p>使用<a href="aop:config">aop:config</a>标签配置aop（将切面、切入点、通知结合到一起）</p>
<ol>
<li>定义切入点表达式</li>
<li><a href="aop:aspect">aop:aspect</a>
<ol>
<li>引用外部定义的切面bean</li>
<li>配置通知，引用切入点表达式</li>
</ol>
</li>
</ol>
<pre><code class="language-xml">&lt;aop:config&gt;
    &lt;!-- 切入点表示匹配com.lanou3g.spring包下的所有类中所有以oneDay开头的方法，方法的参数、返回值不限 --&gt;
	&lt;aop:pointcut id=&quot;myPointcut&quot; expression=&quot;execution(* com.lanou3g.spring..*.oneDay*(..))&quot; /&gt;
    &lt;aop:aspect ref=&quot;myAspect&quot;&gt;
    	&lt;!-- 无论是否出现异常，只要被切入的方法开始运行，都会触发此通知 --&gt;
            &lt;aop:before method=&quot;wakeup&quot; pointcut-ref=&quot;beforeOneDay&quot; /&gt;
            &lt;!-- 无论是否出现异常，只要被切入的方法运行结束，都会触发此通知 --&gt;
            &lt;aop:after method=&quot;goToBed&quot; pointcut-ref=&quot;beforeOneDay&quot; /&gt;
            &lt;!--
            可以最大限度的对被切入方法附加功能，在方法执行前、后都可以通知（无论是否出现异常）
            ，还可以获取到被切入方法的所有信息，包括是否调用被切入的方法
            --&gt;
            &lt;aop:around method=&quot;aroundAdvice&quot; pointcut-ref=&quot;beforeOneDay&quot; /&gt;
            &lt;!-- 被切入的方法正常返回值以后，会触发此通知 --&gt;
            &lt;aop:after-returning method=&quot;afterRetuing&quot; pointcut-ref=&quot;beforeOneDay&quot; returning=&quot;message&quot; /&gt;
            &lt;!-- 被切入的方法抛出异常以后，会触发此通知，并且不会触发after-returning --&gt;
            &lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;beforeOneDay&quot; throwing=&quot;ex&quot; /&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre>
</li>
</ol>
<h3 id="基于注解方式使用">基于注解方式使用</h3>
<ol>
<li>
<p>开启AOP注解支持</p>
<p>方式一：注解的方式</p>
<pre><code class="language-xml">@Configuration
@EnableAspectJAutoProxy
public class AppConfig {

}
</code></pre>
<p>方式二：xml中开启</p>
<pre><code class="language-xml">&lt;aop:aspectj-autoproxy/&gt;
</code></pre>
<ol start="2">
<li>定义切面类</li>
</ol>
<pre><code class="language-java">/**
 * 该切面用来插入起床的逻辑
 */
@Aspect
@Component  //@Aspect注解没有将bean交给ioc容器管理的功能
public class MyAspect {

    @Before(&quot;com.lanou3g.spring.aop.MyPointcut.allOneDayMehtod()&quot;)
    public void wakeup() {
        System.out.println(&quot;[前置通知]我刚学习SpringAOP睡着了，刚才谁打了我一下？&quot;);
    }

    @After(&quot;com.lanou3g.spring.aop.MyPointcut.allOneDayMehtod()&quot;)
    public void goToBed() {
        System.out.println(&quot;[后置通知]SpringAOP太难了，一不小心又睡着了&quot;);
    }

    @AfterReturning(value = &quot;com.lanou3g.spring.aop.MyPointcut.allOneDayMehtod()&quot;, returning = &quot;message&quot;)
    public void afterRetuing(Object message) {
        System.out.println(&quot;[后置返回通知]方法执行已经return了，方法返回值是：&quot; + message);
    }

    @AfterThrowing(value = &quot;com.lanou3g.spring.aop.MyPointcut.allOneDayMehtod()&quot;, throwing = &quot;ex&quot;)
    public void afterThrowing(Throwable ex) {
        System.out.println(&quot;[后置异常通知]方法执行出现异常，异常原因：&quot; + ex.getMessage());
    }

    /**
     * 环绕通知
     * 可以接受一个ProceedingJoinPoint参数
     *      通过此参数可以获取到被切入方法的所有信息
     *      还可以通过此参数来决定是否调用目标方法
     */
//    @Around(&quot;com.lanou3g.spring.aop.MyPointcut.allOneDayMehtod()&quot;)
    public Object aroundAdvice(ProceedingJoinPoint joinPoint) {

        // 连接点参数可以获取到被切入方法的所有信息
        // 这里演示了如何获取被切入方法的名称
        String targetMethodName = joinPoint.getSignature().getName();
        System.out.println(&quot;[环绕通知]被切入的方法名：&quot; + targetMethodName);

        //
        System.out.println(&quot;[环绕通知]即将开始新的一天， 早起的鸟儿有虫吃！&quot;);
        Object ret = null;
        try {
            ret = joinPoint.proceed();
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
        System.out.println(&quot;[环绕通知]这真是充实的一天， 早睡早起，方能养生！&quot;);
        return ret;
    }
}
</code></pre>
<blockquote>
<p>注意：@Aspect注解没有将bean交给ioc容器管理的功能，我们需要额外添加一个@Component注解</p>
</blockquote>
<ol start="3">
<li>定义切入点</li>
</ol>
<p>官方建议我们将所有的切入点统一定义到一个地方管理，在配置通知时通过引入的方式来使用。方便后期维护（一处修改，处处生效）</p>
<pre><code class="language-java">@Component
public class MyPointcut {
    // 通过@Pointcut注解定义一个切入点
    @Pointcut(&quot;execution(* oneDay(..))&quot;)
    public void allOneDayMehtod() {}
}
</code></pre>
<ol start="4">
<li>在切面类中添加要切入的代码</li>
</ol>
<blockquote>
<p>参见定义切面部分</p>
</blockquote>
<ol start="5">
<li>在切入的代码方法上添加通知的注解</li>
</ol>
<blockquote>
<p>参见定义切面部分</p>
</blockquote>
</li>
</ol>
<h2 id="spring-aop代理机制实现原理">Spring AOP代理机制实现原理</h2>
<p>Spring AOP底层支持两种动态实现：</p>
<ul>
<li>JDK原生的动态代理</li>
<li>Cglib动态代理</li>
</ul>
<blockquote>
<p>Spring在创建代理对象时，会自动选择要使用哪种代理方案。如果被代理的类实现了接口，那么就用JDK动态代理； 反之就使用Cglib动态代理</p>
</blockquote>
<h3 id="jdk原生动态代理">JDK原生动态代理</h3>
<p>区别静态代理每代理一个类就需要创建一个专门的代理类，动态代理只需要一个通用的代理类，即可代理所有实现了接口的类。</p>
<p>关键的API:</p>
<ul>
<li>
<p>InvocationHandler: 回调接口</p>
<pre><code class="language-java">public class MyProxy implements InvacationHandler {
    /**
     *  此方法在通过代理对象去调用目标方法时，会自动进入此方法(实际上调用的就是此方法)，目标方法时在此方法中调用的(当然，也可以不调用)。

     *  第一个参数proxy: 代理对象(注意不是目标对象)
     *  第二个参数method: 被代理的方法对象(方法本身)
     *  第三个参数args: 代理对象调用时穿进来的参数，用于在代理方法中调用原方法时传入
     *
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

            String methodName = method.getName();

            // 模拟在方法运行前执行的操作
            System.out.println(methodName+ &quot; 开始执行了&quot;);

            Object retVal =  method.invoke(target, args);

            // 模拟在方法运行后执行的操作
            System.out.println(methodName+ &quot; 执行结束了，返回值： &quot; + retVal);

            return retVal;
    }
}
</code></pre>
</li>
<li>
<p>Proxy： 创建代理类的工厂类，用于动态创建代理对象</p>
<ul>
<li>
<p>如何创建代理对象</p>
<pre><code class="language-java">// 1. 创建代理对象
// 参数说明：
//		第一个参数是类加载器
//		第二个参数是被代理类实现的接口，可以写多个(写几个接口就代表你需要代理从几个接口中实现的方法)
//        第三个参数是一个实现了InvacationHandler接口的对象，用于回调
//        当我们通过代理对象去调用目标方法时，会自动执行第三个参数传进来的回调方法
		
Object obj = Proxy.newProxyInstance(classLoader, interfaces..., callback);

// 2. 将类型强转成需要代理类的接口类型
Man man = (Man)obj;

// 3. 通过代理对象去调用原本想调用的方法
man.oneDay();
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="cglib动态代理">Cglib动态代理</h3>
<p>关键的API</p>
<ul>
<li>
<p>Enhancer: 该类负责动态创建代理</p>
<ul>
<li>如何创建代理类</li>
</ul>
<pre><code class="language-java">Enhancer enhancer = new Enhancer();	//类似于一个创建代理对象的工厂类
// 下面三行类似于给工厂对象设置参数
enhancer.setSuperclass(clazz);	// 让动态创建出来的代理类继承指定的类
enhancer.setCallback(this);	 // 指定调用代理对象的方法时，进入的回调方法
return enhancer.create();	// 创建代理对象
</code></pre>
</li>
<li>
<p>MehtodInctercepor: 执行代理对象方法时的回调，作用类似于JDK动态代理中的InvacationHandler</p>
<pre><code class="language-java">public class MyCglibProxy implements MethodInterceptor {

    // 创建动态代理类的工厂对象
    private Enhancer enhancer = new Enhancer();
    public Object getProxy(Class clazz) {
        enhancer.setSuperclass(clazz);
        enhancer.setCallback(this);
        enhancer.setUseCache(false);
        return enhancer.create();
    }

    /**
     *  此方法在通过代理对象去调用目标方法时，会自动进入此方法(实际上调用的就是此方法)，目标方法时在此方法中调用的(当然，也可以不调用)。

     *  第一个参数proxy: 代理对象(注意不是目标对象)
     *  第二个参数method: 被代理的方法对象(方法本身)
     *  第三个参数args: 代理对象调用时穿进来的参数，用于在代理方法中调用原方法时传入
     *  第四个参数methodProxy: 是Cglib提供的一个方法代理对象，代理了第二个参数method,它可以实现直接调用传进来对象的父类上的方法
     */ 
    @Override
    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        String methodName = method.getName();
        System.out.println(methodName + &quot;开始执行了&quot;);
        //代理类对象实例调用父类方法（其实就是调用被代理类上的方法实现）
        Object retVal = methodProxy.invokeSuper(proxy, args);
        System.out.println(methodName + &quot;执行结束了&quot;);
        return retVal;
    }
}
</code></pre>
</li>
</ul>
<h3 id="两种动态代理对比">两种动态代理对比</h3>
<ul>
<li>JDK动态代理要求被代理的类必须是至少实现一个接口才能代理</li>
<li>Cglib动态代理没有上述限制，也就是说他可以代理实现了接口的类，也可以代理没实现接口的类</li>
<li>JDK动态代理创建代理对象的原理是让创建的代理对象实现和被代理类一样的接口，从而代理接口中的方法</li>
<li>Cglib动态代理创建代理对象的原理是让创建的代理对象继承被代理的目标类，从而代理从父类(被代理的类)中继承过来的方法</li>
</ul>
<h3 id="强制使用cglib方式创建代理">强制使用Cglib方式创建代理</h3>
<p>如果上下文入口是XML配置文件</p>
<pre><code class="language-xml">&lt;!-- 方式一. 局部 --&gt;
&lt;aop:config proxy-target-class=&quot;true&quot;&gt;
    &lt;!-- other beans defined here... --&gt;
&lt;/aop:config&gt;

&lt;!-- 方式二. 全局，在开启注解支持的地方添加属性(通过注解配置的AOP) --&gt;
&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;
</code></pre>
<p>如果上下文入口是注解类</p>
<pre><code class="language-java">@EnableAspectJAutoProxy(proxyTargetClass = true) // 开启AOP注解支持,并强制使用cglib代理
public class MyConfiguration {
}
</code></pre>
<h2 id="spring声明式事务">Spring声明式事务</h2>
<h3 id="在xml中使用声明式事务的步骤">在Xml中使用声明式事务的步骤</h3>
<ol>
<li>
<p>添加tx schema</p>
<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
       http://www.springframework.org/schema/tx/spring-tx.xsd
       http://www.springframework.org/schema/aop
       https://www.springframework.org/schema/aop/spring-aop.xsd
        http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
</code></pre>
</li>
<li>
<p>配置数据源</p>
<pre><code class="language-xml">&lt;!-- 导入外部properties文件 --&gt;
&lt;context:property-placeholder location=&quot;jdbc.properties&quot; /&gt;
&lt;!-- 配置数据库连接池 --&gt;
&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
    &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot; /&gt;
    &lt;property name=&quot;username&quot; value=&quot;${jdbc.user}&quot; /&gt;
    &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>配置事务管理器</p>
<pre><code class="language-xml">&lt;!-- 第一步： 配置事务管理器 --&gt;
&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
    &lt;!-- 事务管理器必须依赖数据源 --&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>配置事务通知，同时还能指定一些事务相关的具体属性</p>
<pre><code class="language-xml">&lt;!-- 第二步： 配置事务通知（不同于我们自己之前配置的前置、后置通知，这个是Spring帮我们封装好的，专门用来做事务管理的通知） --&gt;
&lt;!-- tx:advice封装了切面和通知相关的逻辑，不需要我们自己再去编写切面和通知的逻辑 --&gt;
&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
    &lt;tx:attributes&gt;
        &lt;!-- 只有触发了特定异常才回滚事务 --&gt;
        &lt;tx:method name=&quot;*&quot; rollback-for=&quot;Exception&quot; /&gt;
        &lt;!-- 触发以下特定异常，不会回滚事务 --&gt;
        &lt;tx:method name=&quot;*&quot; no-rollback-for=&quot;NullPointerException&quot; /&gt;
        &lt;!-- 配置只读事务，只能查询，不能修改 --&gt;
        &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot; /&gt;
        &lt;!-- 配置事务超时时间，超时后事务自动回滚，单位：秒，
                仅当传播行为propagation设置成REQUIRED或者REQUIRES_NEW的时候有效 --&gt;
        &lt;tx:method name=&quot;find*&quot; timeout=&quot;500&quot; /&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;
</code></pre>
</li>
<li>
<p>配置事务的AOP</p>
<p>其实就是将Spring给我们封装好的事务切面、通知和切入点整合到一起，通过AOP的方式来工作。</p>
<pre><code class="language-xml">&lt;!-- 第三步： 配置AOP --&gt;
&lt;aop:config&gt;
    &lt;aop:pointcut id=&quot;allServiceMethod&quot; expression=&quot;execution(* com.lanou3g.spring.aoptx..*.*(..))&quot;/&gt;
    &lt;!-- 这个advisor类似于我们手工配置的aop:aspect，它将切面、通知和切入点做了一个整合 --&gt;
    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;allServiceMethod&quot; /&gt;
&lt;/aop:config&gt;
</code></pre>
</li>
</ol>
<h3 id="在注解中使用声明式事务的步骤">在注解中使用声明式事务的步骤</h3>
<ol>
<li>
<p>开启注解事务支持</p>
<p>开启注解事务支持有两种方式</p>
<p>方式一： 在xml配置文件中开启</p>
<pre><code class="language-xml">&lt;!-- 开启事务注解扫描 --&gt;
&lt;!-- 如果定义的事务管理器名称就叫transactionManager，则此属性可以省略 --&gt;
&lt;tx:annotation-driven transaction-manager=&quot;txManager&quot; /&gt;
</code></pre>
<p>方式二：在注解配置类上开启，添加<code>@EnableTransactionManagement</code>注解</p>
<pre><code class="language-java">@Configuration
@EnableTransactionManagement
@ComponentScan(basePackages = &quot;com.lanou3g.spring&quot;)
@PropertySource(&quot;classpath:jdbc.properties&quot;)
public class MyConfiguration {
    
}
</code></pre>
</li>
<li>
<p>配置数据源</p>
<pre><code class="language-java">/**
* 配置数据源
* @return
*/
@Bean
public DataSource dataSource() {
    DriverManagerDataSource dataSource = new DriverManagerDataSource();
    dataSource.setDriverClassName(driver);
    dataSource.setUrl(url);
    dataSource.setUsername(user);
    dataSource.setPassword(password);
    return dataSource;
}
</code></pre>
</li>
<li>
<p>配置事务管理器</p>
<pre><code class="language-java">/**
 * 配置事务管理器
 * @param dataSource
 * @return
 */
@Bean
public PlatformTransactionManager transactionManager(DataSource dataSource) {
    return new DataSourceTransactionManager(dataSource);
}
</code></pre>
</li>
<li>
<p>在需要事务管理的方法上添加<code>@Transactional</code>注解</p>
<pre><code class="language-java">// 凡是xml中支持的事务属性，在注解中都有对应的属性来实现，具体属性含义参见xml配置
@Transactional(
    rollbackFor = Exception.class   // 指定哪些异常可以触发事务回滚
    //noRollbackFor =   // 指定事务不回滚哪些异常
    //            isolation =   // 指定事务隔离级别
    //            timeout =     // 指定事务超时时间
    //            propagation = // 指定事务传播行为
    //            readOnly = // 指定只读事务
)
public void login(User user) {

    // Service中只写业务操作代码，不需要关注事务管理
    // 1 更新用户表用户最后登录时间
    user.setLastLoginTime(new Timestamp(System.currentTimeMillis()));
    userDao.updateUser(user);

    int ret = 9 / 0;  // 模拟操作异常

    // 2 插入登录日志
    SystemLog log = new SystemLog();
    log.setAction(&quot;login&quot;);
    log.setOperator(user.getUserName());
    log.setCreateTime(new Date());
    systemLogDao.insertLog(log);
}
</code></pre>
<blockquote>
<p>@Transactional注解除了可以在方法上使用外，还可以在类上。表示类中所有的公开方法都添加此事务管理</p>
</blockquote>
</li>
</ol>
<h3 id="xml方式的事务和注解方式的事务该选哪个">XML方式的事务和注解方式的事务该选哪个？</h3>
<ul>
<li>XML方式的事务
<ul>
<li>优点是对代码没有任何侵入性，修改事务相关逻辑时，只需要修改配置文件，无需重新编译代码。另外XML方式可以通过切入点表达式灵活的对大量的类添加事务管理。</li>
<li>缺点是配置相较于注解方式麻烦一些</li>
</ul>
</li>
<li>注解方式的事务
<ul>
<li>优点是配置简单，使用方便</li>
<li>缺点是无法统一对大量的方法添加事务管理，需要在添加事务的类或方法上一个个添加事务注解，当工程中需要事务管理的代码很多时，工作量就比XML方式还要大。</li>
</ul>
</li>
</ul>
<h3 id="spring事务的传播行为和隔离级别">Spring事务的传播行为和隔离级别</h3>
<h4 id="事务的传播行为">事务的传播行为</h4>
<p>事务传播描述的事务与事务之间的传播关系， 常见的场景是在一个嵌套调用的方法中，外部方法和内部每个方法都添加了事务管理， 不同的传播行为配置，决定了最终是这些方法是使用同一个事务，还是在不同的事务中运行。</p>
<ul>
<li>
<p>PROPAGATION_REQUIRED</p>
<p>支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。</p>
</li>
<li>
<p>PROPAGATION_SUPPORTS</p>
<p>支持当前事务，如果当前没有事务，就以非事务方式执行。</p>
</li>
<li>
<p>PROPAGATION_MANDATORY</p>
<p>支持当前事务，如果当前没有事务，就抛出异常。</p>
</li>
<li>
<p>PROPAGATION_REQUIRES_NEW</p>
<p>新建事务，如果当前存在事务，把当前事务挂起。</p>
</li>
<li>
<p>PROPAGATION_NOT_SUPPORTED</p>
<p>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p>
</li>
<li>
<p>PROPAGATION_NEVER</p>
<p>以非事务方式执行，如果当前存在事务，则抛出异常。</p>
</li>
<li>
<p>PROPAGATION_NESTED</p>
<p>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。</p>
</li>
</ul>
<h4 id="事务的隔离级别">事务的隔离级别</h4>
<p>事务的隔离级别描述的是多个事务之间的可见性问题。比如一个事务还未提交时，其他事务是否能看到被未提交事务修改的数据。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ISOLATION_DEFAULT</td>
<td>这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别.</td>
</tr>
<tr>
<td>ISOLATION_READ_UNCOMMITTED</td>
<td>这是事务最低的隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。 这种隔离级别会产生脏读，不可重复读和幻像读。</td>
</tr>
<tr>
<td>ISOLATION_READ_COMMITTED</td>
<td>保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。 这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。</td>
</tr>
<tr>
<td>ISOLATION_REPEATABLE_READ</td>
<td>这种事务隔离级别可以防止脏读、不可重复读。但是可能出现幻像读。 它保证了一个事务不能修改已经由另一个事务读取但还未提交的数据</td>
</tr>
<tr>
<td>ISOLATION_SERIALIZABLE</td>
<td>这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。 除了防止脏读，不可重复读外，还避免了幻像读。</td>
</tr>
</tbody>
</table>
<h5 id="关键词">关键词：</h5>
<ul>
<li>幻读（虚读）</li>
</ul>
<blockquote>
<p>事务1读取记录时事务2增加了记录并提交，事务1再次读取时可以看到事务2新增的记录；<br>
通俗的说，幻读就是指在一个事务内读取了别的事务插入的数据，导致前后读取不一致(insert)</p>
</blockquote>
<ul>
<li>不可重复读取</li>
</ul>
<blockquote>
<p>事务1读取记录时，事务2更新了记录并提交，事务1再次读取时可以看到事务2修改后的记录；<br>
在一个事务内读取表中的某一行数据,多次读取结果不同.一个事务读取到了另一个事务提交后的数据.</p>
</blockquote>
<ul>
<li>脏读</li>
</ul>
<blockquote>
<p>事务1更新了记录，但没有提交，事务2读取了更新后的行，然后事务T1回滚，现在T2读取无效。<br>
通俗的说，脏读就是指一个事务读取了一个未提交事务的数据</p>
</blockquote>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#ioc%E5%AE%B9%E5%99%A8%E6%A6%82%E5%BF%B5">IOC容器概念</a></li>
<li><a href="#ioc%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F">IOC容器初始化方式</a>
<ul>
<li><a href="#classpathxmlapplicationcontext">ClassPathXmlApplicationContext</a></li>
<li><a href="#annotationconfigapplicationcontext">AnnotationConfigApplicationContext</a></li>
</ul>
</li>
<li><a href="#bean%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F">Bean初始化方式</a>
<ul>
<li><a href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%96%B9%E5%BC%8F%E6%9C%80%E5%B8%B8%E7%94%A8">构造方法方式（最常用）</a></li>
<li><a href="#%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95">静态工厂方法</a></li>
<li><a href="#%E5%AE%9E%E4%BE%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95">实例工厂方法</a></li>
</ul>
</li>
<li><a href="#bean%E7%9A%84%E5%91%BD%E5%90%8D">Bean的命名</a></li>
<li><a href="#bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F">Bean的作用域</a></li>
<li><a href="#bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">Bean的生命周期</a></li>
<li><a href="#bean%E6%87%92%E5%8A%A0%E8%BD%BD">Bean懒加载</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%81%9C%E6%AD%A2%E9%9D%9Eweb-spring%E5%BA%94%E7%94%A8">如何优雅的停止非Web Spring应用</a></li>
</ul>
</li>
<li><a href="#spring-di">Spring DI</a>
<ul>
<li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li>
<li><a href="#di%E7%9A%84%E7%BB%86%E8%8A%82%E5%AE%9E%E7%8E%B0">DI的细节实现</a>
<ul>
<li><a href="#%E6%9E%84%E9%80%A0%E5%8F%82%E6%95%B0%E6%B3%A8%E5%85%A5">构造参数注入</a></li>
<li><a href="#setter%E6%B3%A8%E5%85%A5">Setter注入</a></li>
<li><a href="#%E6%94%AF%E6%8C%81%E6%B3%A8%E5%85%A5%E7%9A%84%E7%B1%BB%E5%9E%8B">支持注入的类型</a></li>
<li><a href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D">自动装配</a><br>
*
<ul>
<li><a href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%94%AF%E6%8C%81%E7%9A%84%E7%AD%96%E7%95%A5">自动装配支持的策略</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#xml%E6%96%B9%E5%BC%8F%E7%9A%84di">XML方式的DI</a>
<ul>
<li><a href="#%E6%9E%84%E9%80%A0%E5%8F%82%E6%95%B0%E6%B3%A8%E5%85%A5-2">构造参数注入</a></li>
<li><a href="#setter%E6%96%B9%E5%BC%8F%E6%B3%A8%E5%85%A5">setter方式注入</a></li>
<li><a href="#%E5%BC%80%E5%90%AF%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D">开启自动装配</a></li>
<li><a href="#%E6%8F%90%E9%AB%98%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%97%B6%E7%9A%84%E6%9D%83%E9%87%8D">提高自动装配时的权重</a></li>
<li><a href="#%E6%8C%89%E7%B1%BB%E5%9E%8B%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%97%B6%E4%B8%8D%E5%8F%82%E4%B8%8E%E5%80%99%E9%80%89">按类型自动装配时，不参与候选</a></li>
</ul>
</li>
<li><a href="#%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E7%9A%84di">注解方式的DI</a>
<ul>
<li><a href="#%E6%8F%90%E9%AB%98%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%97%B6%E7%9A%84%E6%9D%83%E9%87%8D-2">提高自动装配时的权重</a></li>
</ul>
</li>
<li><a href="#%E6%B3%A8%E5%85%A5%E5%A4%96%E9%83%A8property%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7%E5%80%BC">注入外部Property文件中的属性值</a>
<ul>
<li><a href="#%E5%9C%A8xml%E4%B8%AD%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F">在XML中的配置方式</a></li>
<li><a href="#%E5%9C%A8%E6%B3%A8%E8%A7%A3%E4%B8%AD%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F">在注解中的配置方式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#springaop">SpringAOP</a>
<ul>
<li><a href="#%E6%A6%82%E8%BF%B0-2">概述</a>
<ul>
<li><a href="#springaop%E5%92%8Caspectj%E7%9A%84%E5%8C%BA%E5%88%AB">SpringAOP和AspectJ的区别</a></li>
</ul>
</li>
<li><a href="#aop%E7%9A%84%E6%9C%AF%E8%AF%AD">AOP的术语</a></li>
<li><a href="#%E5%9C%A8spring%E4%B8%AD%E4%BD%BF%E7%94%A8aop">在Spring中使用AOP</a>
<ul>
<li><a href="#%E5%9F%BA%E4%BA%8Exml%E6%96%B9%E5%BC%8F%E4%BD%BF%E7%94%A8">基于XML方式使用</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E4%BD%BF%E7%94%A8">基于注解方式使用</a></li>
</ul>
</li>
<li><a href="#spring-aop%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">Spring AOP代理机制实现原理</a>
<ul>
<li><a href="#jdk%E5%8E%9F%E7%94%9F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">JDK原生动态代理</a></li>
<li><a href="#cglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">Cglib动态代理</a></li>
<li><a href="#%E4%B8%A4%E7%A7%8D%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AF%B9%E6%AF%94">两种动态代理对比</a></li>
<li><a href="#%E5%BC%BA%E5%88%B6%E4%BD%BF%E7%94%A8cglib%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86">强制使用Cglib方式创建代理</a></li>
</ul>
</li>
<li><a href="#spring%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1">Spring声明式事务</a>
<ul>
<li><a href="#%E5%9C%A8xml%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%AD%A5%E9%AA%A4">在Xml中使用声明式事务的步骤</a></li>
<li><a href="#%E5%9C%A8%E6%B3%A8%E8%A7%A3%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%AD%A5%E9%AA%A4">在注解中使用声明式事务的步骤</a></li>
<li><a href="#xml%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%92%8C%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BA%8B%E5%8A%A1%E8%AF%A5%E9%80%89%E5%93%AA%E4%B8%AA">XML方式的事务和注解方式的事务该选哪个？</a></li>
<li><a href="#spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%E5%92%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">Spring事务的传播行为和隔离级别</a>
<ul>
<li><a href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA">事务的传播行为</a></li>
<li><a href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">事务的隔离级别</a>
<ul>
<li><a href="#%E5%85%B3%E9%94%AE%E8%AF%8D">关键词：</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://zjt-zjt.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()

  let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

  // This should probably be throttled.
  // Especially because it triggers during smooth scrolling.
  // https://lodash.com/docs/4.17.10#throttle
  // You could do like...
  // window.addEventListener("scroll", () => {
  //    _.throttle(doThatStuff, 100);
  // });
  // Only not doing it here to keep this Pen dependency-free.

  window.addEventListener("scroll", event => {
    let fromTop = window.scrollY;

    mainNavLinks.forEach((link, index) => {
      let section = document.getElementById(decodeURI(link.hash).substring(1));
      let nextSection = null
      if (mainNavLinks[index + 1]) {
        nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
      }
      if (section.offsetTop <= fromTop) {
        if (nextSection) {
          if (nextSection.offsetTop > fromTop) {
            link.classList.add("current");
          } else {
            link.classList.remove("current");    
          }
        } else {
          link.classList.add("current");
        }
      } else {
        link.classList.remove("current");
      }
    });
  });

</script>

      </div>
    </div>
  </body>
</html>
