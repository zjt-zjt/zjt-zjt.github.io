<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zjt-zjt.github.io</id>
    <title>Gridea</title>
    <updated>2019-12-11T11:21:53.586Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zjt-zjt.github.io"/>
    <link rel="self" href="https://zjt-zjt.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://zjt-zjt.github.io/images/avatar.png</logo>
    <icon>https://zjt-zjt.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[Spring]]></title>
        <id>https://zjt-zjt.github.io/post/spring</id>
        <link href="https://zjt-zjt.github.io/post/spring">
        </link>
        <updated>2019-05-02T11:00:31.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h2 id="ioc容器概念">IOC容器概念</h2>
<p>IOC其实就是一个对象的容器。全称Inversion Of Control 控制反转，核心的作用就是将原来由开发人员来控制的对象管理操作交由Spring来管理。</p>
<p>SpringIOC不仅帮我们管理了对象的创建，还包括给对象增加了生命周期行为、作用域(单例、非单例)、懒加载。 配合Spring的DI， 更能方便的解决对象属性值注入、对象之间的依赖注入问题。</p>
<h2 id="ioc容器初始化方式">IOC容器初始化方式</h2>
<h3 id="classpathxmlapplicationcontext">ClassPathXmlApplicationContext</h3>
<p>该类负责加载类路径下的xml配置文件的方式，去初始化IOC容器上下文，具体使用步骤如下：</p>
<ol>
<li>
<p>编写配置文件</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    
    &lt;!-- 使用bean标签将对象配置到ioc容器中 --&gt;
    &lt;bean id=&quot;man&quot; class=&quot;com.lanou3g.bean.Man&quot; /&gt;
    &lt;bean id=&quot;apple&quot; class=&quot;com.lanou3g.bean.Food&quot; /&gt;
&lt;/beans&gt;
</code></pre>
</li>
<li>
<p>加载配置文件，初始化IOC容器</p>
</li>
</ol>
<pre><code class="language-java">   // 加载单个xml配置，初始化上下文
   ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext1.xml&quot;);
  
   // 加载多个xml配置，初始化上下文
   ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(new String[]{&quot;applicationContext1.xml&quot;, &quot;applicationContext2.xml&quot;});
  
   // 加载当前运行类所在的类路径下所有以application开头的配置文件
   ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;appliction*.xml&quot;);
  
   // 加载工程中所有类路径下所有以application开头的配置文件
   ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath*:appliction*.xml&quot;);
  
   // 加载工程中所有类路径下所有以application或spring开头的配置文件
   ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(new String[]{&quot;classpath*:appliction*.xml&quot;, &quot;classpath*:spring*.xml&quot;});
</code></pre>
<blockquote>
<p>配置文件路径中可以包含通配符(*)和前缀(classpath*:，代表所有类路径，包括源码类路径和单元测试类路径)</p>
</blockquote>
<ol start="3">
<li>
<p>从容器中获取对象</p>
<pre><code class="language-java">// 通过xml中配置的bean的id或name属性的值获取bean, 返回的类型是Object，需要强转成对象真正的类型
Man man = (Man) cxt.getBean(&quot;man&quot;); 
// 通过bean的名称获取bean的同时，指定类型 
Man man1 = cxt.getBean(&quot;man&quot;,Man.class); 
// 通过类型从容器中获取bean，如果容器中该类型的bean有多于一个，则会报错
Man man2 = cxt.getBean(Man.class); 

// 调用对象的方法
man.eat();
man.play();
</code></pre>
</li>
</ol>
<h3 id="annotationconfigapplicationcontext">AnnotationConfigApplicationContext</h3>
<p>加载通过Java注解方式配置的Bean上下文。具体使用步骤如下：</p>
<ol>
<li>
<p>定义配置类</p>
<pre><code class="language-java">@Configuration	//代表该类是一个bean的配置类，类似于xml配置中的&lt;beans&gt;标签
public class MyConfiguration {

}
</code></pre>
<ol>
<li>
<p>开启注解支持，配置扫描包路径</p>
<p>如果是通过ClassPathXmlApplicationContext初始化的上下文，则在xml中添加如下配置：</p>
<pre><code class="language-xml">&lt;!-- 添加context命名空间 --&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

&lt;!-- 下面两个配置用于xml和注解配置混合使用时，开启注解扫描支持，并指定扫描的包路径 --&gt;
&lt;!-- 如果指定了扫描包路径，该配置可省略 --&gt;
&lt;context:annotation-config /&gt; 
&lt;context:component-scan base-package=&quot;com.lanou3g.spring&quot; /&gt;
</code></pre>
<p>如果是通过AnnotationConfigApplicationContext初始化的上下文，则需要在t通过<code>@Configuration</code>注解标注的配置类上添加 @ComponentScans注解：</p>
<pre><code class="language-java">@Configuration
@ComponentScan(basePackages = &quot;com.lanou.spring&quot;) //指定扫描包路径
public class MyConfiguration {

}
</code></pre>
</li>
<li>
<p>配置Bean</p>
<p>通过注解方式有两种方式可以将类的对象交由IOC容器中管理</p>
<ul>
<li>
<p>通过@Component的方式定义</p>
<pre><code class="language-java">@Component
public class King {
}
</code></pre>
<blockquote>
<p>适用于我们自己定义的类，或者我们可以修改源代码的类</p>
</blockquote>
</li>
<li>
<p>通过@Bean注解定义</p>
<pre><code class="language-java">public class King {
}


@Configuration
public class MyApplicationContextConf {
    @Bean
    public King king() {
        return new King();
    }
}
</code></pre>
<blockquote>
<p>适用于需要将第三方jar包中的类交由ioc管理，因为我们不能修改jar包中的代码，无法给其添加@Component注解</p>
</blockquote>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p>加载配置类，初始化IOC容器</p>
<pre><code class="language-java">// 加载单个注解配置，初始化上下文
AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(MyConfiguration.class);

// 加载多个注解配置，初始化上下文
AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(new Class[]{MyConfiguration1.class, MyConfiguration2.class});
</code></pre>
</li>
<li>
<p>从容器中获取bean</p>
<pre><code class="language-java">// 通过xml中配置的bean的id或name属性的值获取bean, 返回的类型是Object，需要强转成对象真正的类型
Man man = (Man) cxt.getBean(&quot;man&quot;); 
// 通过bean的名称获取bean的同时，指定类型 
Man man1 = cxt.getBean(&quot;man&quot;,Man.class); 
// 通过类型从容器中获取bean，如果容器中该类型的bean有多于一个，则会报错
Man man2 = cxt.getBean(Man.class); 

// 调用对象的方法
man.eat();
man.play();
</code></pre>
</li>
</ol>
<h2 id="bean初始化方式">Bean初始化方式</h2>
<h3 id="构造方法方式最常用">构造方法方式（最常用）</h3>
<pre><code class="language-xml">&lt;bean id=&quot;xx&quot; class=&quot;com.test.StudentDao&quot; /&gt;
</code></pre>
<h3 id="静态工厂方法">静态工厂方法</h3>
<pre><code class="language-xml">&lt;!-- 
	class：指定的是静态工厂类，而不是将要创建的对象类型
	factory-method: 指定的是工厂中的静态方法 
--&gt;
&lt;bean id=&quot;xx&quot; class=&quot;com.test.StudentDaoFactory&quot; factory-method=&quot;createDao&quot; /&gt;
</code></pre>
<h3 id="实例工厂方法">实例工厂方法</h3>
<pre><code class="language-xml">&lt;!-- 
	class：指定的是实例工厂类 
--&gt;
&lt;bean id=&quot;xxFactory&quot; class=&quot;com.test.StudentDaoFactory&quot; /&gt;
&lt;!-- 
	factory-bean：指定的是实例工厂对象
	factory-method: 指定的是工厂中的实例方法 
--&gt;
&lt;bean id=&quot;xx&quot; factory-bean=&quot;xxFactory&quot; factory-method=&quot;createDao&quot; /&gt;
</code></pre>
<h2 id="bean的命名">Bean的命名</h2>
<p>在XML中配置中可以通过<bean>标签上的id、name属性值给一个bean命名，以便在其他地方引用。</p>
<p>id属性： bean的唯一名称，只允许出现一个值。且同一个IOC容器中不允许出现两个id值一样的bean。</p>
<p>name属性： 和id类似也是给bean命名。但是name属性的值可以有多个，多个值之间使用英文逗号(,)或者英文分号(;)或者空格符隔开</p>
<h2 id="bean的作用域">Bean的作用域</h2>
<ul>
<li>
<p>prototype</p>
<p>在SpringIOC中prototype scope的意思指的是非单例，就是每次使用该bean的时候都会重新创建一个对象。</p>
<figure data-type="image" tabindex="1"><img src="https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/images/prototype.png" alt="原型作用域示意图"></figure>
</li>
<li>
<p>singleton(默认)</p>
<p>singleton作用域是IOC中默认的作用域，代表单例。每次使用bean的时候，不会重新创建对象，在整个IOC容器中该类型的对象只有一个。</p>
<figure data-type="image" tabindex="2"><img src="https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/images/singleton.png" alt="单例作用域示意图"></figure>
</li>
</ul>
<h2 id="bean的生命周期">Bean的生命周期</h2>
<ul>
<li>Singleton Bean的生命周期
<ul>
<li>初始化时机： 在IOC容器初始化时，就会把配置的所有单例bean实例化。</li>
<li>销毁时机：在IOC容器销毁时，所有bean的销毁方法会被调用。</li>
</ul>
</li>
<li>Prototype Bean的生命周期
<ul>
<li>初始化时机： 在实际使用该bean的时候，比如：getBean、获取依赖此bean的其他bean需要使用</li>
<li>销毁时机： 在IOC容器销毁时。（但是通过destroy-method指定的声明周期方法不会被调用，也就是说Spring不提供prototypebean完整的生命周期管理）</li>
</ul>
</li>
<li>如何指定生命周期的回调方法
<ul>
<li>xml中的init-method、destroy-method</li>
<li>注解方式@PostConstrutor、@PreDestroy</li>
</ul>
</li>
<li>指定默认的声明周期回调方法
<ul>
<li>在xml中，通过在beans标签上添加default-init-method、default-destory-method来指定</li>
<li>在注解配置中，没有对应的方法可以设置所有bean默认的生命周期回调</li>
</ul>
</li>
</ul>
<h2 id="bean懒加载">Bean懒加载</h2>
<p>lazy-init属性</p>
<p>默认是false</p>
<blockquote>
<p>懒加载配置主要是针对单例的bean，因为它默认是在容器初始化时就被实例化了。</p>
</blockquote>
<h2 id="如何优雅的停止非web-spring应用">如何优雅的停止非Web Spring应用</h2>
<p>添加一个shutdown hook。所有派生自ConfigurableApplicationContext接口的实现类都支持此方法</p>
<pre><code class="language-java">ConfigurableApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;xxx.xml&quot;);

ctx.registerShutdownHook(); //注册停止回调
</code></pre>
<h1 id="spring-di">Spring DI</h1>
<h2 id="概述">概述</h2>
<p>DI的全称是Dependency Injection（依赖注入）。IOC是将我们工程中的所有对象交由Spring来管理，DI是此基础，将对象中的属性、依赖的其他对象也管理起来，自动注入到由Spring帮我们管理的对象中。</p>
<blockquote>
<p>将要注入的对象和目标对象都必须是由SpringIOC管理的bean.</p>
</blockquote>
<h2 id="di的细节实现">DI的细节实现</h2>
<h3 id="构造参数注入">构造参数注入</h3>
<p>将一个bean创建过程中构造方法需要的参数，通过Spring DI的方式，自动注入到构造方法中。</p>
<h3 id="setter注入">Setter注入</h3>
<p>先通过一个无参的构造方法创建对象，然后通过属性的setter方法，将属性值注入到对象上。</p>
<h3 id="支持注入的类型">支持注入的类型</h3>
<ul>
<li>
<p>普通字面量</p>
<ul>
<li>String</li>
<li>Integer(int)</li>
<li>Long(long)</li>
<li>Byte(byte)</li>
<li>...</li>
</ul>
</li>
<li>
<p>集和类型</p>
<ul>
<li>
<p>List</p>
<pre><code class="language-xml">&lt;bean id=&quot;xxx&quot; class=&quot;xx.xxx.xxx.AA&quot;&gt;&lt;/bean&gt;
&lt;bean&gt;
    &lt;property name=&quot;hobbies&quot;&gt;
    	&lt;list&gt;
        	&lt;value&gt;简单类型值&lt;/value&gt;
            &lt;bean&gt;内部bean&lt;/bean&gt;
            &lt;ref bean=&quot;xxx&quot; /&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>Map</p>
<pre><code class="language-xml">&lt;bean id=&quot;xxx&quot; class=&quot;xx.xxx.xxx.AA&quot;&gt;&lt;/bean&gt;
&lt;bean&gt;
    &lt;property name=&quot;gameTitle&quot;&gt;
    	&lt;map&gt;
        	&lt;entry key=&quot;王者荣耀&quot; value=&quot;荣耀王者&quot; /&gt;
            &lt;entry key=&quot;王者荣耀&quot; value-ref=&quot;xxx&quot; /&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>Set</p>
<pre><code class="language-xml">&lt;bean id=&quot;xxx&quot; class=&quot;xx.xxx.xxx.AA&quot;&gt;&lt;/bean&gt;
&lt;bean&gt;
    &lt;property name=&quot;hobbies&quot;&gt;
    	&lt;!-- set用法和List类似， 里面可以注入普通字面量值、也可以是一个bean引用，或者内部bean、或者是一个set、list、Properties  --&gt;
        &lt;set&gt;
        	&lt;value&gt;简单类型值&lt;/value&gt;
            &lt;bean&gt;内部bean&lt;/bean&gt;
            &lt;ref bean=&quot;xxx&quot; /&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>java.util.Properties</p>
<pre><code class="language-xml">&lt;!-- props标签是用来注入java.util.Properties类型的属性，用法和map类似，但是属性值是在标签中间写 --&gt;
&lt;property name=&quot;gameNick&quot;&gt;
    &lt;props&gt;
        &lt;prop key=&quot;王者荣耀&quot;&gt;最擅长1V5&lt;/prop&gt;
        &lt;prop key=&quot;吃鸡&quot;&gt;一枪爆头&lt;/prop&gt;
    &lt;/props&gt;
&lt;/property&gt;
</code></pre>
</li>
<li>
<p>注入空置、空字符串</p>
<pre><code class="language-xml">&lt;property name=&quot;gameNick&quot;&gt;
    &lt;null /&gt;
&lt;/property&gt;


&lt;property name=&quot;gameNick&quot; value=&quot;&quot; /&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="自动装配">自动装配</h3>
<h5 id="自动装配支持的策略">自动装配支持的策略</h5>
<ul>
<li>
<p>byType</p>
<p>按照类型去IOC容器中找需要的bean，如果找到一个，则自动装配；如果没找到，不注入此属性；如果找到了多个匹配类型的bean，就会报错。</p>
</li>
<li>
<p>byName</p>
<p>按照名称去IOC容器中找需要的bean，如果找到就自动注入；如果没找到，不注入此属性。</p>
</li>
<li>
<p>constructor</p>
<p>工作原理和byType类似，也是按照类型去IOC容器中找对应的bean。不同的是注入的地方不是setter，而是构造方法的参数。</p>
</li>
<li>
<p>no  （默认值）</p>
<p>如果没有打开自动注入，默认Spring不会自动装配需要的属性。</p>
</li>
</ul>
<h2 id="xml方式的di">XML方式的DI</h2>
<h3 id="构造参数注入-2">构造参数注入</h3>
<ul>
<li>
<p>常规写法</p>
<pre><code class="language-xml">&lt;bean id=&quot;xx&quot; class=&quot;&quot; /&gt;
&lt;bean class=&quot;com.test.XXX&quot;&gt;
	&lt;constructor-arg name=&quot;age&quot; value=&quot;45&quot; /&gt;
    &lt;constructor-arg name=&quot;x&quot; ref=&quot;xx&quot; /&gt;  &lt;!-- 注入引用的bean --&gt;
    &lt;constructor-arg name=&quot;&quot;&gt;	&lt;!-- 注入内部bean --&gt;
    	&lt;bean&gt;&lt;/bean&gt;
    &lt;/constructor-arg&gt;
    &lt;constructor-arg name=&quot;&quot;&gt;	&lt;!-- 注入list类型构造参数 --&gt;
    	&lt;list&gt;
        	
        &lt;/list&gt;
    &lt;/constructor-arg&gt;
    ....
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>c命名空间简写</p>
<pre><code class="language-xml">&lt;bean id=&quot;xx&quot; class=&quot;&quot; /&gt;
&lt;bean class=&quot;com.test.XXX&quot; c:age=&quot;45&quot; c:x-ref=&quot;xx&quot; /&gt;
</code></pre>
</li>
</ul>
<h3 id="setter方式注入">setter方式注入</h3>
<p>setter注入能够注入的类型以及写法基本和构造参数注入时的写法一致，只不过将<construtor-arg>标签换成了<property></p>
<ul>
<li>
<p>常规用法</p>
<pre><code class="language-xml">&lt;bean id=&quot;xx&quot; class=&quot;&quot; /&gt;
&lt;bean class=&quot;com.test.XXX&quot;&gt;
	&lt;property name=&quot;age&quot; value=&quot;45&quot; /&gt;
    &lt;property name=&quot;x&quot; ref=&quot;xx&quot; /&gt;  &lt;!-- 注入引用的bean --&gt;
    &lt;property name=&quot;&quot;&gt;	&lt;!-- 注入内部bean --&gt;
    	&lt;bean&gt;&lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name=&quot;&quot;&gt;	&lt;!-- 注入list类型构造参数 --&gt;
    	&lt;list&gt;
        	
        &lt;/list&gt;
    &lt;/property&gt;
    ....
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>p命名空间简写</p>
<pre><code class="language-xml">&lt;bean id=&quot;xx&quot; class=&quot;&quot; /&gt;
&lt;bean class=&quot;com.test.XXX&quot; p:age=&quot;45&quot; p:x-ref=&quot;xx&quot; /&gt;
</code></pre>
</li>
</ul>
<h3 id="开启自动装配">开启自动装配</h3>
<pre><code class="language-xml">&lt;!-- 
通过给当前的bean添加autowire属性开启自动注入
可选的值：参见自动装配章节
 --&gt;
&lt;bean id=&quot;xx&quot; class=&quot;&quot; autowire=&quot;&quot; /&gt;
</code></pre>
<h3 id="提高自动装配时的权重">提高自动装配时的权重</h3>
<pre><code class="language-xml">&lt;!-- 当其他的bean中需要注入一个Test类型的属性，而满足条件的bean有多个时，会优先注入primary=&quot;true&quot;的bean --&gt;
&lt;bean id=&quot;xx&quot; class=&quot;com.Test&quot; primary=&quot;true&quot; /&gt;
</code></pre>
<h3 id="按类型自动装配时不参与候选">按类型自动装配时，不参与候选</h3>
<pre><code class="language-xml">&lt;!-- 当其他的bean中需要注入一个Test类型的属性，而满足条件的bean有多个时，autowire-candidate=&quot;false&quot;的bean会自动退出候选序列 --&gt;
&lt;bean id=&quot;xx&quot; class=&quot;com.Test&quot; autowire-candidate=&quot;false&quot; /&gt;
</code></pre>
<h2 id="注解方式的di">注解方式的DI</h2>
<ul>
<li>
<p>构造参数注入</p>
<p>在构造方法上添加 <code>@Autowired</code>注解，构造方法的参数就会自动注入进来</p>
</li>
<li>
<p>setter方法注入</p>
<p>方法有两种：</p>
<ol>
<li>在属性的setter方法上添加<code>@Autowired</code>注解</li>
<li>在属性上添加<code>@Autowired</code>注解</li>
</ol>
</li>
</ul>
<h3 id="提高自动装配时的权重-2">提高自动装配时的权重</h3>
<pre><code class="language-java">@Primary
@Component
public class Test {


}

public class Main {
    
    @Primary
    @Bean
    public void test() {
        return new Test();
    }
    
}
</code></pre>
<h2 id="注入外部property文件中的属性值">注入外部Property文件中的属性值</h2>
<h3 id="在xml中的配置方式">在XML中的配置方式</h3>
<pre><code class="language-xml">&lt;!-- 添加context命名空间 --&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;


&lt;!-- 导入外部properties文件到ioc上下文中 --&gt;
&lt;context:property-placeholder location=&quot;jdbc.properties&quot; /&gt;

&lt;!-- 使用占位符的方式获取properties文件中的属性值 --&gt;
&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt;
    &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;
    &lt;property name=&quot;username&quot; value=&quot;${jdbc.user}&quot; /&gt;
    &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="在注解中的配置方式">在注解中的配置方式</h3>
<p>通过<code>@PropertySource</code>注解可以将外部properties文件导入到上下文中，通过<code>@Value</code>注解可以获取properties文件中的属性值，并注入到当前类的属性中</p>
<pre><code class="language-java">@Configuration
@ComponentScan(basePackages = &quot;com.lanou.spring&quot;)
@PropertySource(&quot;classpath:/jdbc.properties&quot;)
public class MyConfiguration {

	@Value(&quot;${jdbc.url}&quot;)
    private String url;
    @Value(&quot;${jdbc.user}&quot;)
    private String username;
    @Value(&quot;${jdbc.password}&quot;)
    private String password;
    @Value(&quot;${jdbc.driver}&quot;)
    private String driverClassName;
}
</code></pre>
<h1 id="springaop">SpringAOP</h1>
<h2 id="概述-2">概述</h2>
<p>AOP的全称是Aspect Oriented  Programming(面向切面编程)</p>
<p>OOP语言提供了类与类之间纵向的关系（继承、接口），而AOP补充了横向的关系（比如在不改变目标类中源代码的情况下给com.john.demo.dao包下所有类中以insert和update开头的方法添加事务管理）</p>
<h3 id="springaop和aspectj的区别">SpringAOP和AspectJ的区别</h3>
<p>AspectJ是一个专门主打面向切面编程的框架。 它是使用一种特殊的语言(扩展自Java语言)来编写切面代码，后缀是.aj格式，并且需要使用专门的编译器将其编译成jvm可以运行的class文件。</p>
<p>SpringAOP底层也是使用了AspectJ的方案，但是在上层做了很多封装层面的工作，可以让开发人员直接使用Java代码来编写切面。并且由于使用的是标准的Java语言，所以并不需要在额外安装一个专门的编译器。但是由于开发人员直接接触的是Spring AOP，那么凡是Spring中没有实现的那些AOP功能，我们就用不了了，这种情况下只能跟产品经理撕逼或者去学习原生的AspectJ。</p>
<h2 id="aop的术语">AOP的术语</h2>
<ul>
<li>
<p>切面（Aspect）</p>
<p>简单来说，切面就是我们要往目标代码中插入进去的代码。</p>
</li>
<li>
<p>连接点（Join Pointer）</p>
<p>理论上所有可能会被切入的地方都可以称之为连接点</p>
</li>
<li>
<p>切入点(Pointcut)</p>
<p>选择某个连接点切入，将切面代码织入进去。这个连接点就叫做切入点。</p>
</li>
<li>
<p>织入(Weaving)</p>
<p>把切面代码糅合到目标代码中的过程就是织入。</p>
</li>
<li>
<p>通知(Advice)</p>
<p>通知决定了切面代码织入到目标代码中后，运行的时机(比如是在目标方法执行前，还是执行后)。</p>
</li>
</ul>
<h2 id="在spring中使用aop">在Spring中使用AOP</h2>
<h3 id="基于xml方式使用">基于XML方式使用</h3>
<ol>
<li>
<p>把aop的schema引入</p>
<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
</code></pre>
</li>
<li>
<p>创建一个切面类，并且以bean的方式配置到IOC容器中</p>
<pre><code class="language-java">package com.lanou3g.spring;
public class MyAspect {

    public void wakeup() {
        System.out.println(&quot;[前置通知]我刚学习SpringAOP睡着了，刚才谁打了我一下？&quot;);
    }


    public void goToBed() {
        System.out.println(&quot;[后置通知]SpringAOP太难了，一不小心又睡着了&quot;);
    }


    public void afterRetuing(Object message) {
        System.out.println(&quot;[后置返回通知]方法执行已经return了，方法返回值是：&quot; + message);
    }

    public void afterThrowing(Throwable ex) {
        System.out.println(&quot;[后置异常通知]方法执行出现异常，异常原因：&quot; + ex.getMessage());
    }

    /**
     * 环绕通知
     * 可以接受一个ProceedingJoinPoint参数
     *      通过此参数可以获取到被切入方法的所有信息
     *      还可以通过此参数来决定是否调用目标方法
     */
    public void aroundAdvice(ProceedingJoinPoint joinPoint) {

        // 连接点参数可以获取到被切入方法的所有信息
        // 这里演示了如何获取被切入方法的名称
        String targetMethodName = joinPoint.getSignature().getName();
        System.out.println(&quot;[环绕通知]被切入的方法名：&quot; + targetMethodName);

        //
        System.out.println(&quot;[环绕通知]即将开始新的一天， 早起的鸟儿有虫吃！&quot;);
        try {
            joinPoint.proceed();
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
        System.out.println(&quot;[环绕通知]这真是充实的一天， 早睡早起，方能养生！&quot;);
    }
}
</code></pre>
<pre><code class="language-xml">&lt;bean id=&quot;myAspect&quot; class=&quot;com.lanou3g.spring.MyAspect&quot; /&gt;
</code></pre>
</li>
<li>
<p>使用<a href="aop:config">aop:config</a>标签配置aop（将切面、切入点、通知结合到一起）</p>
<ol>
<li>定义切入点表达式</li>
<li><a href="aop:aspect">aop:aspect</a>
<ol>
<li>引用外部定义的切面bean</li>
<li>配置通知，引用切入点表达式</li>
</ol>
</li>
</ol>
<pre><code class="language-xml">&lt;aop:config&gt;
    &lt;!-- 切入点表示匹配com.lanou3g.spring包下的所有类中所有以oneDay开头的方法，方法的参数、返回值不限 --&gt;
	&lt;aop:pointcut id=&quot;myPointcut&quot; expression=&quot;execution(* com.lanou3g.spring..*.oneDay*(..))&quot; /&gt;
    &lt;aop:aspect ref=&quot;myAspect&quot;&gt;
    	&lt;!-- 无论是否出现异常，只要被切入的方法开始运行，都会触发此通知 --&gt;
            &lt;aop:before method=&quot;wakeup&quot; pointcut-ref=&quot;beforeOneDay&quot; /&gt;
            &lt;!-- 无论是否出现异常，只要被切入的方法运行结束，都会触发此通知 --&gt;
            &lt;aop:after method=&quot;goToBed&quot; pointcut-ref=&quot;beforeOneDay&quot; /&gt;
            &lt;!--
            可以最大限度的对被切入方法附加功能，在方法执行前、后都可以通知（无论是否出现异常）
            ，还可以获取到被切入方法的所有信息，包括是否调用被切入的方法
            --&gt;
            &lt;aop:around method=&quot;aroundAdvice&quot; pointcut-ref=&quot;beforeOneDay&quot; /&gt;
            &lt;!-- 被切入的方法正常返回值以后，会触发此通知 --&gt;
            &lt;aop:after-returning method=&quot;afterRetuing&quot; pointcut-ref=&quot;beforeOneDay&quot; returning=&quot;message&quot; /&gt;
            &lt;!-- 被切入的方法抛出异常以后，会触发此通知，并且不会触发after-returning --&gt;
            &lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;beforeOneDay&quot; throwing=&quot;ex&quot; /&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre>
</li>
</ol>
<h3 id="基于注解方式使用">基于注解方式使用</h3>
<ol>
<li>
<p>开启AOP注解支持</p>
<p>方式一：注解的方式</p>
<pre><code class="language-xml">@Configuration
@EnableAspectJAutoProxy
public class AppConfig {

}
</code></pre>
<p>方式二：xml中开启</p>
<pre><code class="language-xml">&lt;aop:aspectj-autoproxy/&gt;
</code></pre>
<ol start="2">
<li>定义切面类</li>
</ol>
<pre><code class="language-java">/**
 * 该切面用来插入起床的逻辑
 */
@Aspect
@Component  //@Aspect注解没有将bean交给ioc容器管理的功能
public class MyAspect {

    @Before(&quot;com.lanou3g.spring.aop.MyPointcut.allOneDayMehtod()&quot;)
    public void wakeup() {
        System.out.println(&quot;[前置通知]我刚学习SpringAOP睡着了，刚才谁打了我一下？&quot;);
    }

    @After(&quot;com.lanou3g.spring.aop.MyPointcut.allOneDayMehtod()&quot;)
    public void goToBed() {
        System.out.println(&quot;[后置通知]SpringAOP太难了，一不小心又睡着了&quot;);
    }

    @AfterReturning(value = &quot;com.lanou3g.spring.aop.MyPointcut.allOneDayMehtod()&quot;, returning = &quot;message&quot;)
    public void afterRetuing(Object message) {
        System.out.println(&quot;[后置返回通知]方法执行已经return了，方法返回值是：&quot; + message);
    }

    @AfterThrowing(value = &quot;com.lanou3g.spring.aop.MyPointcut.allOneDayMehtod()&quot;, throwing = &quot;ex&quot;)
    public void afterThrowing(Throwable ex) {
        System.out.println(&quot;[后置异常通知]方法执行出现异常，异常原因：&quot; + ex.getMessage());
    }

    /**
     * 环绕通知
     * 可以接受一个ProceedingJoinPoint参数
     *      通过此参数可以获取到被切入方法的所有信息
     *      还可以通过此参数来决定是否调用目标方法
     */
//    @Around(&quot;com.lanou3g.spring.aop.MyPointcut.allOneDayMehtod()&quot;)
    public Object aroundAdvice(ProceedingJoinPoint joinPoint) {

        // 连接点参数可以获取到被切入方法的所有信息
        // 这里演示了如何获取被切入方法的名称
        String targetMethodName = joinPoint.getSignature().getName();
        System.out.println(&quot;[环绕通知]被切入的方法名：&quot; + targetMethodName);

        //
        System.out.println(&quot;[环绕通知]即将开始新的一天， 早起的鸟儿有虫吃！&quot;);
        Object ret = null;
        try {
            ret = joinPoint.proceed();
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
        System.out.println(&quot;[环绕通知]这真是充实的一天， 早睡早起，方能养生！&quot;);
        return ret;
    }
}
</code></pre>
<blockquote>
<p>注意：@Aspect注解没有将bean交给ioc容器管理的功能，我们需要额外添加一个@Component注解</p>
</blockquote>
<ol start="3">
<li>定义切入点</li>
</ol>
<p>官方建议我们将所有的切入点统一定义到一个地方管理，在配置通知时通过引入的方式来使用。方便后期维护（一处修改，处处生效）</p>
<pre><code class="language-java">@Component
public class MyPointcut {
    // 通过@Pointcut注解定义一个切入点
    @Pointcut(&quot;execution(* oneDay(..))&quot;)
    public void allOneDayMehtod() {}
}
</code></pre>
<ol start="4">
<li>在切面类中添加要切入的代码</li>
</ol>
<blockquote>
<p>参见定义切面部分</p>
</blockquote>
<ol start="5">
<li>在切入的代码方法上添加通知的注解</li>
</ol>
<blockquote>
<p>参见定义切面部分</p>
</blockquote>
</li>
</ol>
<h2 id="spring-aop代理机制实现原理">Spring AOP代理机制实现原理</h2>
<p>Spring AOP底层支持两种动态实现：</p>
<ul>
<li>JDK原生的动态代理</li>
<li>Cglib动态代理</li>
</ul>
<blockquote>
<p>Spring在创建代理对象时，会自动选择要使用哪种代理方案。如果被代理的类实现了接口，那么就用JDK动态代理； 反之就使用Cglib动态代理</p>
</blockquote>
<h3 id="jdk原生动态代理">JDK原生动态代理</h3>
<p>区别静态代理每代理一个类就需要创建一个专门的代理类，动态代理只需要一个通用的代理类，即可代理所有实现了接口的类。</p>
<p>关键的API:</p>
<ul>
<li>
<p>InvocationHandler: 回调接口</p>
<pre><code class="language-java">public class MyProxy implements InvacationHandler {
    /**
     *  此方法在通过代理对象去调用目标方法时，会自动进入此方法(实际上调用的就是此方法)，目标方法时在此方法中调用的(当然，也可以不调用)。

     *  第一个参数proxy: 代理对象(注意不是目标对象)
     *  第二个参数method: 被代理的方法对象(方法本身)
     *  第三个参数args: 代理对象调用时穿进来的参数，用于在代理方法中调用原方法时传入
     *
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

            String methodName = method.getName();

            // 模拟在方法运行前执行的操作
            System.out.println(methodName+ &quot; 开始执行了&quot;);

            Object retVal =  method.invoke(target, args);

            // 模拟在方法运行后执行的操作
            System.out.println(methodName+ &quot; 执行结束了，返回值： &quot; + retVal);

            return retVal;
    }
}
</code></pre>
</li>
<li>
<p>Proxy： 创建代理类的工厂类，用于动态创建代理对象</p>
<ul>
<li>
<p>如何创建代理对象</p>
<pre><code class="language-java">// 1. 创建代理对象
// 参数说明：
//		第一个参数是类加载器
//		第二个参数是被代理类实现的接口，可以写多个(写几个接口就代表你需要代理从几个接口中实现的方法)
//        第三个参数是一个实现了InvacationHandler接口的对象，用于回调
//        当我们通过代理对象去调用目标方法时，会自动执行第三个参数传进来的回调方法
		
Object obj = Proxy.newProxyInstance(classLoader, interfaces..., callback);

// 2. 将类型强转成需要代理类的接口类型
Man man = (Man)obj;

// 3. 通过代理对象去调用原本想调用的方法
man.oneDay();
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="cglib动态代理">Cglib动态代理</h3>
<p>关键的API</p>
<ul>
<li>
<p>Enhancer: 该类负责动态创建代理</p>
<ul>
<li>如何创建代理类</li>
</ul>
<pre><code class="language-java">Enhancer enhancer = new Enhancer();	//类似于一个创建代理对象的工厂类
// 下面三行类似于给工厂对象设置参数
enhancer.setSuperclass(clazz);	// 让动态创建出来的代理类继承指定的类
enhancer.setCallback(this);	 // 指定调用代理对象的方法时，进入的回调方法
return enhancer.create();	// 创建代理对象
</code></pre>
</li>
<li>
<p>MehtodInctercepor: 执行代理对象方法时的回调，作用类似于JDK动态代理中的InvacationHandler</p>
<pre><code class="language-java">public class MyCglibProxy implements MethodInterceptor {

    // 创建动态代理类的工厂对象
    private Enhancer enhancer = new Enhancer();
    public Object getProxy(Class clazz) {
        enhancer.setSuperclass(clazz);
        enhancer.setCallback(this);
        enhancer.setUseCache(false);
        return enhancer.create();
    }

    /**
     *  此方法在通过代理对象去调用目标方法时，会自动进入此方法(实际上调用的就是此方法)，目标方法时在此方法中调用的(当然，也可以不调用)。

     *  第一个参数proxy: 代理对象(注意不是目标对象)
     *  第二个参数method: 被代理的方法对象(方法本身)
     *  第三个参数args: 代理对象调用时穿进来的参数，用于在代理方法中调用原方法时传入
     *  第四个参数methodProxy: 是Cglib提供的一个方法代理对象，代理了第二个参数method,它可以实现直接调用传进来对象的父类上的方法
     */ 
    @Override
    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        String methodName = method.getName();
        System.out.println(methodName + &quot;开始执行了&quot;);
        //代理类对象实例调用父类方法（其实就是调用被代理类上的方法实现）
        Object retVal = methodProxy.invokeSuper(proxy, args);
        System.out.println(methodName + &quot;执行结束了&quot;);
        return retVal;
    }
}
</code></pre>
</li>
</ul>
<h3 id="两种动态代理对比">两种动态代理对比</h3>
<ul>
<li>JDK动态代理要求被代理的类必须是至少实现一个接口才能代理</li>
<li>Cglib动态代理没有上述限制，也就是说他可以代理实现了接口的类，也可以代理没实现接口的类</li>
<li>JDK动态代理创建代理对象的原理是让创建的代理对象实现和被代理类一样的接口，从而代理接口中的方法</li>
<li>Cglib动态代理创建代理对象的原理是让创建的代理对象继承被代理的目标类，从而代理从父类(被代理的类)中继承过来的方法</li>
</ul>
<h3 id="强制使用cglib方式创建代理">强制使用Cglib方式创建代理</h3>
<p>如果上下文入口是XML配置文件</p>
<pre><code class="language-xml">&lt;!-- 方式一. 局部 --&gt;
&lt;aop:config proxy-target-class=&quot;true&quot;&gt;
    &lt;!-- other beans defined here... --&gt;
&lt;/aop:config&gt;

&lt;!-- 方式二. 全局，在开启注解支持的地方添加属性(通过注解配置的AOP) --&gt;
&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;
</code></pre>
<p>如果上下文入口是注解类</p>
<pre><code class="language-java">@EnableAspectJAutoProxy(proxyTargetClass = true) // 开启AOP注解支持,并强制使用cglib代理
public class MyConfiguration {
}
</code></pre>
<h2 id="spring声明式事务">Spring声明式事务</h2>
<h3 id="在xml中使用声明式事务的步骤">在Xml中使用声明式事务的步骤</h3>
<ol>
<li>
<p>添加tx schema</p>
<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
       http://www.springframework.org/schema/tx/spring-tx.xsd
       http://www.springframework.org/schema/aop
       https://www.springframework.org/schema/aop/spring-aop.xsd
        http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
</code></pre>
</li>
<li>
<p>配置数据源</p>
<pre><code class="language-xml">&lt;!-- 导入外部properties文件 --&gt;
&lt;context:property-placeholder location=&quot;jdbc.properties&quot; /&gt;
&lt;!-- 配置数据库连接池 --&gt;
&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
    &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot; /&gt;
    &lt;property name=&quot;username&quot; value=&quot;${jdbc.user}&quot; /&gt;
    &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>配置事务管理器</p>
<pre><code class="language-xml">&lt;!-- 第一步： 配置事务管理器 --&gt;
&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
    &lt;!-- 事务管理器必须依赖数据源 --&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>配置事务通知，同时还能指定一些事务相关的具体属性</p>
<pre><code class="language-xml">&lt;!-- 第二步： 配置事务通知（不同于我们自己之前配置的前置、后置通知，这个是Spring帮我们封装好的，专门用来做事务管理的通知） --&gt;
&lt;!-- tx:advice封装了切面和通知相关的逻辑，不需要我们自己再去编写切面和通知的逻辑 --&gt;
&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
    &lt;tx:attributes&gt;
        &lt;!-- 只有触发了特定异常才回滚事务 --&gt;
        &lt;tx:method name=&quot;*&quot; rollback-for=&quot;Exception&quot; /&gt;
        &lt;!-- 触发以下特定异常，不会回滚事务 --&gt;
        &lt;tx:method name=&quot;*&quot; no-rollback-for=&quot;NullPointerException&quot; /&gt;
        &lt;!-- 配置只读事务，只能查询，不能修改 --&gt;
        &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot; /&gt;
        &lt;!-- 配置事务超时时间，超时后事务自动回滚，单位：秒，
                仅当传播行为propagation设置成REQUIRED或者REQUIRES_NEW的时候有效 --&gt;
        &lt;tx:method name=&quot;find*&quot; timeout=&quot;500&quot; /&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;
</code></pre>
</li>
<li>
<p>配置事务的AOP</p>
<p>其实就是将Spring给我们封装好的事务切面、通知和切入点整合到一起，通过AOP的方式来工作。</p>
<pre><code class="language-xml">&lt;!-- 第三步： 配置AOP --&gt;
&lt;aop:config&gt;
    &lt;aop:pointcut id=&quot;allServiceMethod&quot; expression=&quot;execution(* com.lanou3g.spring.aoptx..*.*(..))&quot;/&gt;
    &lt;!-- 这个advisor类似于我们手工配置的aop:aspect，它将切面、通知和切入点做了一个整合 --&gt;
    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;allServiceMethod&quot; /&gt;
&lt;/aop:config&gt;
</code></pre>
</li>
</ol>
<h3 id="在注解中使用声明式事务的步骤">在注解中使用声明式事务的步骤</h3>
<ol>
<li>
<p>开启注解事务支持</p>
<p>开启注解事务支持有两种方式</p>
<p>方式一： 在xml配置文件中开启</p>
<pre><code class="language-xml">&lt;!-- 开启事务注解扫描 --&gt;
&lt;!-- 如果定义的事务管理器名称就叫transactionManager，则此属性可以省略 --&gt;
&lt;tx:annotation-driven transaction-manager=&quot;txManager&quot; /&gt;
</code></pre>
<p>方式二：在注解配置类上开启，添加<code>@EnableTransactionManagement</code>注解</p>
<pre><code class="language-java">@Configuration
@EnableTransactionManagement
@ComponentScan(basePackages = &quot;com.lanou3g.spring&quot;)
@PropertySource(&quot;classpath:jdbc.properties&quot;)
public class MyConfiguration {
    
}
</code></pre>
</li>
<li>
<p>配置数据源</p>
<pre><code class="language-java">/**
* 配置数据源
* @return
*/
@Bean
public DataSource dataSource() {
    DriverManagerDataSource dataSource = new DriverManagerDataSource();
    dataSource.setDriverClassName(driver);
    dataSource.setUrl(url);
    dataSource.setUsername(user);
    dataSource.setPassword(password);
    return dataSource;
}
</code></pre>
</li>
<li>
<p>配置事务管理器</p>
<pre><code class="language-java">/**
 * 配置事务管理器
 * @param dataSource
 * @return
 */
@Bean
public PlatformTransactionManager transactionManager(DataSource dataSource) {
    return new DataSourceTransactionManager(dataSource);
}
</code></pre>
</li>
<li>
<p>在需要事务管理的方法上添加<code>@Transactional</code>注解</p>
<pre><code class="language-java">// 凡是xml中支持的事务属性，在注解中都有对应的属性来实现，具体属性含义参见xml配置
@Transactional(
    rollbackFor = Exception.class   // 指定哪些异常可以触发事务回滚
    //noRollbackFor =   // 指定事务不回滚哪些异常
    //            isolation =   // 指定事务隔离级别
    //            timeout =     // 指定事务超时时间
    //            propagation = // 指定事务传播行为
    //            readOnly = // 指定只读事务
)
public void login(User user) {

    // Service中只写业务操作代码，不需要关注事务管理
    // 1 更新用户表用户最后登录时间
    user.setLastLoginTime(new Timestamp(System.currentTimeMillis()));
    userDao.updateUser(user);

    int ret = 9 / 0;  // 模拟操作异常

    // 2 插入登录日志
    SystemLog log = new SystemLog();
    log.setAction(&quot;login&quot;);
    log.setOperator(user.getUserName());
    log.setCreateTime(new Date());
    systemLogDao.insertLog(log);
}
</code></pre>
<blockquote>
<p>@Transactional注解除了可以在方法上使用外，还可以在类上。表示类中所有的公开方法都添加此事务管理</p>
</blockquote>
</li>
</ol>
<h3 id="xml方式的事务和注解方式的事务该选哪个">XML方式的事务和注解方式的事务该选哪个？</h3>
<ul>
<li>XML方式的事务
<ul>
<li>优点是对代码没有任何侵入性，修改事务相关逻辑时，只需要修改配置文件，无需重新编译代码。另外XML方式可以通过切入点表达式灵活的对大量的类添加事务管理。</li>
<li>缺点是配置相较于注解方式麻烦一些</li>
</ul>
</li>
<li>注解方式的事务
<ul>
<li>优点是配置简单，使用方便</li>
<li>缺点是无法统一对大量的方法添加事务管理，需要在添加事务的类或方法上一个个添加事务注解，当工程中需要事务管理的代码很多时，工作量就比XML方式还要大。</li>
</ul>
</li>
</ul>
<h3 id="spring事务的传播行为和隔离级别">Spring事务的传播行为和隔离级别</h3>
<h4 id="事务的传播行为">事务的传播行为</h4>
<p>事务传播描述的事务与事务之间的传播关系， 常见的场景是在一个嵌套调用的方法中，外部方法和内部每个方法都添加了事务管理， 不同的传播行为配置，决定了最终是这些方法是使用同一个事务，还是在不同的事务中运行。</p>
<ul>
<li>
<p>PROPAGATION_REQUIRED</p>
<p>支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。</p>
</li>
<li>
<p>PROPAGATION_SUPPORTS</p>
<p>支持当前事务，如果当前没有事务，就以非事务方式执行。</p>
</li>
<li>
<p>PROPAGATION_MANDATORY</p>
<p>支持当前事务，如果当前没有事务，就抛出异常。</p>
</li>
<li>
<p>PROPAGATION_REQUIRES_NEW</p>
<p>新建事务，如果当前存在事务，把当前事务挂起。</p>
</li>
<li>
<p>PROPAGATION_NOT_SUPPORTED</p>
<p>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p>
</li>
<li>
<p>PROPAGATION_NEVER</p>
<p>以非事务方式执行，如果当前存在事务，则抛出异常。</p>
</li>
<li>
<p>PROPAGATION_NESTED</p>
<p>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。</p>
</li>
</ul>
<h4 id="事务的隔离级别">事务的隔离级别</h4>
<p>事务的隔离级别描述的是多个事务之间的可见性问题。比如一个事务还未提交时，其他事务是否能看到被未提交事务修改的数据。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ISOLATION_DEFAULT</td>
<td>这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别.</td>
</tr>
<tr>
<td>ISOLATION_READ_UNCOMMITTED</td>
<td>这是事务最低的隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。 这种隔离级别会产生脏读，不可重复读和幻像读。</td>
</tr>
<tr>
<td>ISOLATION_READ_COMMITTED</td>
<td>保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。 这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。</td>
</tr>
<tr>
<td>ISOLATION_REPEATABLE_READ</td>
<td>这种事务隔离级别可以防止脏读、不可重复读。但是可能出现幻像读。 它保证了一个事务不能修改已经由另一个事务读取但还未提交的数据</td>
</tr>
<tr>
<td>ISOLATION_SERIALIZABLE</td>
<td>这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。 除了防止脏读，不可重复读外，还避免了幻像读。</td>
</tr>
</tbody>
</table>
<h5 id="关键词">关键词：</h5>
<ul>
<li>幻读（虚读）</li>
</ul>
<blockquote>
<p>事务1读取记录时事务2增加了记录并提交，事务1再次读取时可以看到事务2新增的记录；<br>
通俗的说，幻读就是指在一个事务内读取了别的事务插入的数据，导致前后读取不一致(insert)</p>
</blockquote>
<ul>
<li>不可重复读取</li>
</ul>
<blockquote>
<p>事务1读取记录时，事务2更新了记录并提交，事务1再次读取时可以看到事务2修改后的记录；<br>
在一个事务内读取表中的某一行数据,多次读取结果不同.一个事务读取到了另一个事务提交后的数据.</p>
</blockquote>
<ul>
<li>脏读</li>
</ul>
<blockquote>
<p>事务1更新了记录，但没有提交，事务2读取了更新后的行，然后事务T1回滚，现在T2读取无效。<br>
通俗的说，脏读就是指一个事务读取了一个未提交事务的数据</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mybatis]]></title>
        <id>https://zjt-zjt.github.io/post/mybatis</id>
        <link href="https://zjt-zjt.github.io/post/mybatis">
        </link>
        <updated>2019-04-17T09:05:51.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h2 id="mybatis介绍">Mybatis介绍</h2>
<h2 id="mybatis简单使用">Mybatis简单使用</h2>
<ol>
<li>
<p>初始化SqlSessionFactory对象</p>
<p>SqlSessionFactory对象需要从一个核心配置文件中构建，因此我们创建SqlSessionFactory对象之前需要先配置一个Mybatis核心配置文件</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;!-- 引入外部properties文件,路径从类路径的根目录开始 --&gt;
    &lt;properties resource=&quot;jdbc.properties&quot; /&gt;

    &lt;settings&gt;
        &lt;!-- 开启将数据库中下划线连接的字段自动映射为Java的小驼峰命名 --&gt;
        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
    &lt;/settings&gt;

    &lt;!-- 定义类型别名，在xxxMapper.xml文件中就可以用别名代替很长的类名 --&gt;
    &lt;typeAliases&gt;
        
            &lt;!-- 单个类配置别名 --&gt;
&lt;!--        &lt;typeAlias type=&quot;com.lanou3g.mybatis.bean.User&quot; alias=&quot;User&quot; /&gt;--&gt;
        
            &lt;!-- 统一配置某个包下所有类的别名, 会使用 Bean 的首字母小写的类名来作为它的别名。 --&gt;
        &lt;package name=&quot;com.lanou3g.mybatis.bean&quot; /&gt;
    &lt;/typeAliases&gt;


    &lt;!-- 配置不同环境的参数 --&gt;
    &lt;environments default=&quot;development&quot;&gt;
        &lt;!-- 开发环境数据库、事务配置 --&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;!-- 事务管理使用JDBC的事务 --&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;!-- 配置开发环境数据源 --&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;${jdbc.user}&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;
                &lt;!-- 将所有driver.开头的参数，附加到url属性的值后面上 --&gt;
                &lt;property name=&quot;driver.characterEncoding&quot; value=&quot;utf8&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;

    &lt;!-- 将mapper SQL映射文件包含进来 --&gt;
    &lt;mappers&gt;
        &lt;!-- 将通过XML方式配置的mapper引入进来 --&gt;
        &lt;mapper resource=&quot;mapper/userMapper.xml&quot;/&gt;
        &lt;!-- 将通过注解方式配置的mapper引入进来 --&gt;
&lt;!--        &lt;mapper class=&quot;com.lanou3g.mybatis.mapper.UserMapper&quot; /&gt;--&gt;

        &lt;!-- 将com.lanou3g.mybatis.mapper包下所有通过注解方式配置的mapper引入进来 --&gt;
&lt;!--        &lt;package name=&quot;com.lanou3g.mybatis.mapper&quot;/&gt;--&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<p>构建对象</p>
<pre><code class="language-java">// 1. 初始化mybatis配置
String confPath = &quot;mybatis_conf.xml&quot;;
InputStream in = Resources.getResourceAsStream(confPath);

// 2. 构建SqlSessionFactory对象
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in);
</code></pre>
</li>
<li>
<p>创建SqlSession对象</p>
<p>通过上一步的SqlSessionFactory对象可以获取到负责执行SQL语句的SqlSession对象</p>
<pre><code class="language-java">// 3. 获取SqlSession对象，默认事务不自动提交
// SqlSession sqlSession = sqlSessionFactory.openSession();
// 获取一个自动提交事务的sqlSession
SqlSession sqlSession = sqlSessionFactory.openSession(true);
</code></pre>
</li>
<li>
<p>用SqlSession对象从Mybatis中获取Mapper接口的实现类</p>
<pre><code class="language-java">// 4. 获取Mapper
UserMapper mapper = sqlSession.getMapper(UserMapper.class);
</code></pre>
</li>
<li>
<p>编写Mapper对象的xml配置文件</p>
<p>XML格式的Mapper配置文件类似于接口的实现类，它指定了具体要执行的SQL语句，以及结果集如何映射。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.lanou3g.mybatis.mapper.UserMapper&quot;&gt;
    &lt;select id=&quot;queryAllUser&quot; resultType=&quot;user&quot;&gt;
        select * from user
     &lt;/select&gt;

    &lt;insert id=&quot;insertUser&quot;&gt;
      insert into user (username,nick_name,email)
      values (#{username},#{nickName},#{email})
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre>
</li>
</ol>
<h2 id="深入了解mybatis">深入了解Mybatis</h2>
<h3 id="主要组件">主要组件</h3>
<h4 id="核心配置文件">核心配置文件</h4>
<p>核心配置文件是Mybatis的入口，它里面可以配置mybatis的具体参数、数据源、类型别名、关联映射文件等。。</p>
<p>具体的参数配置说明参见：</p>
<p><a href="https://mybatis.org/mybatis-3/zh/configuration.html">Mybatis3核心配置文件官方说明</a></p>
<h4 id="sqlsessionfactory">SqlSessionFactory</h4>
<p>一个SqlSessionFactory只能连接一个数据库实例，如果需要连接多个数据库，需要构建多个SqlSessionFactory对象。</p>
<p>在构建SqlSesssionFactory时可以指定environment的id，表示使用指定的数据源来构建factory对象</p>
<pre><code class="language-java">SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in, &quot;dev&quot;);
</code></pre>
<h4 id="sqlsession">SqlSession</h4>
<p>一个SqlSession对象代表一次到数据的会话，该对象有一下功能：</p>
<ul>
<li>获取Mapper实现类</li>
<li>管理事务操作</li>
</ul>
<blockquote>
<p>注意： SqlSession对象是非线程安全的，在多线程环境下，建议不要作为类的实例属性来用。</p>
</blockquote>
<h4 id="mapper">Mapper</h4>
<ul>
<li>
<p>Mapper接口类</p>
<p>定义了增删盖查的方法。注意，必须是接口类型，而且方法只需要定义就可以了。</p>
</li>
<li>
<p>Mapper配置文件</p>
<p>Mapper配置文件中就是负责实现接口中的方法，它定义了具体要执行什么SQL语句，如何映射结果集。</p>
<ul>
<li>配置文件中select、delete、update、insert标签的id必须是对应接口中的方法名。</li>
<li>mapper文件的namespace属性需要对应Mapper接口的完全类型限定名。</li>
</ul>
</li>
</ul>
<h3 id="深入mybatis核心配置文件">深入Mybatis核心配置文件</h3>
<p>具体的参数配置说明参见：</p>
<p><a href="https://mybatis.org/mybatis-3/zh/configuration.html">Mybatis3核心配置文件官方说明</a></p>
<h3 id="深入mybatis映射配置文件">深入Mybatis映射配置文件</h3>
<h4 id="crud语句定义">CRUD语句定义</h4>
<h5 id="查询语句">查询语句</h5>
<p>接口中</p>
<pre><code class="language-java">List&lt;User&gt; queryAllUser();

User queryUserById(Integer id);
</code></pre>
<p>xml配置文件中</p>
<pre><code class="language-xml">&lt;select id=&quot;queryAllUser&quot; resultType=&quot;user&quot;&gt;
    select * from user
&lt;/select&gt;

&lt;select id=&quot;queryUserById&quot; resultType=&quot;user&quot;&gt;
    select * from user where id = #{id}
&lt;/select&gt;
</code></pre>
<h5 id="插入语句">插入语句</h5>
<h6 id="普通插入语句">普通插入语句</h6>
<p>接口中</p>
<pre><code class="language-java">int insertUser(User user);
</code></pre>
<p>xml配置文件中</p>
<pre><code class="language-xml">&lt;insert id=&quot;insertUser&quot;&gt;
    insert into user (username,nick_name,email)
    values (#{username},#{nickName},#{email})
&lt;/insert&gt;
</code></pre>
<h6 id="如何返回数据库自增的id">如何返回数据库自增的ID</h6>
<pre><code class="language-xml">&lt;!-- 给insert语句添加useGeneratedKeys、keyProperty后，mybatis会将自增的id值直接赋值到传进来的user对象的id属性上
        useGeneratedKeys: 指定需要获取数据库自增的id
        keyProperty: 指定自增地段的名称
     --&gt;
&lt;insert id=&quot;insertUser&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
    insert into user (username,nick_name,email)
    values (#{username},#{nickName},#{email})
&lt;/insert&gt;
</code></pre>
<h5 id="删除语句">删除语句</h5>
<p>接口中</p>
<pre><code class="language-java">void deleteUserById(Integer id);
</code></pre>
<p>XML配置中</p>
<pre><code class="language-xml">&lt;delete id=&quot;deleteUserById&quot;&gt;
    delete from user where id = #{id}
&lt;/delete&gt;
</code></pre>
<h5 id="更新语句">更新语句</h5>
<p>接口中</p>
<pre><code class="language-java">void updateUser(User user);
</code></pre>
<p>XML配置中</p>
<pre><code class="language-xml">&lt;update id=&quot;updateUser&quot;&gt;
    update user set password = #{password} where id = #{id}
&lt;/update&gt;
</code></pre>
<h4 id="接口中的参数如果传递到sql中">接口中的参数如果传递到SQL中</h4>
<h5 id="简单类型参数">简单类型参数</h5>
<p>接口中：</p>
<pre><code class="language-java">void deleteUserById(Integer id);
</code></pre>
<p>xml配置文件中：</p>
<pre><code class="language-xml">&lt;delete id=&quot;deleteUserById&quot;&gt;
    delete from user where id = #{id}
&lt;/delete&gt;
</code></pre>
<h5 id="引用类型参数">引用类型参数</h5>
<p>接口中：</p>
<pre><code class="language-java">int insertUser(User user);
</code></pre>
<p>xml配置文件中：</p>
<pre><code class="language-xml">&lt;!-- 给insert语句添加useGeneratedKeys、keyProperty后，mybatis会将自增的id值直接赋值到传进来的user对象的id属性上
        useGeneratedKeys: 指定需要获取数据库自增的id
        keyProperty: 指定自增地段的名称
     --&gt;
&lt;insert id=&quot;insertUser&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
    insert into user (username,nick_name,email)
    values (#{username},#{nickName},#{email})
&lt;/insert&gt;
</code></pre>
<h5 id="当接口中参数和xml配置取值时名称不一样时">当接口中参数和XML配置取值时名称不一样时</h5>
<p>在接口中的参数前加注解</p>
<pre><code class="language-java">User queryUserById(@Param(&quot;id&quot;) Integer xxxxxxxId);
</code></pre>
<p>在XML中取值时用注解指定的名称</p>
<pre><code class="language-xml">&lt;select id=&quot;queryUserById&quot; resultType=&quot;user&quot;&gt;
    select * from user where id = #{id}
&lt;/select&gt;
</code></pre>
<h5 id="与的区别">#{}与${}的区别</h5>
<ul>
<li>它俩都可以获取接口调用中传递过来的参数</li>
<li>#{}会将参数作为占位符，使用预编译语句(PreparedStatement)执行</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow></mrow><mi mathvariant="normal">会</mi><mi mathvariant="normal">直</mi><mi mathvariant="normal">接</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">实</mi><mi mathvariant="normal">际</mi><mi mathvariant="normal">参</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">替</mi><mi mathvariant="normal">换</mi></mrow><annotation encoding="application/x-tex">{}会直接用实际参数替换</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord"></span><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">直</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">实</span><span class="mord cjk_fallback">际</span><span class="mord cjk_fallback">参</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">替</span><span class="mord cjk_fallback">换</span></span></span></span>{}， 参数可以作为SQL的一部分。</li>
</ul>
<p>比如，要实现下面的效果：</p>
<p>Java代码</p>
<pre><code class="language-java">List&lt;User&gt; queryAllUserOrderBy(String order);

// 调用：
mapper.queryAllUserOrderBy(&quot;last_login_time&quot;);
</code></pre>
<p>XML配置：</p>
<pre><code class="language-xml">&lt;select id=&quot;queryAllUserOrderBy&quot; resultMap=&quot;userMap&quot;&gt;
    select * from user order by ${order} desc;
&lt;/select&gt;
</code></pre>
<p>如果上面使用#{order}取获取参数，最终执行的SQL会是这样：</p>
<pre><code>==&gt;  Preparing: select * from user order by ? desc; 
==&gt; Parameters: last_login_time(String)
</code></pre>
<p>无法实现排序效果</p>
<p>如果使用${order}来取参数，最终执行SQL：</p>
<pre><code>==&gt;  Preparing: select * from user order by last_login_time desc; 
==&gt; Parameters: 
</code></pre>
<p>可以实现排序效果</p>
<h4 id="结果集如何映射">结果集如何映射</h4>
<h5 id="resulttype方式">ResultType方式</h5>
<p>ResultType方式适用于数据库结果集可以直接映射成一个Java类的情况</p>
<p>Java实体类：</p>
<pre><code class="language-java">@Getter
@Setter
@ToString
public class User {
    private Integer id;
    private String username;
    private String nickName;
    private String password;
    private String email;
    private Timestamp lastLoginTime;
}
</code></pre>
<p>使用方法：</p>
<pre><code class="language-xml">&lt;select id=&quot;queryAllUser&quot; resultType=&quot;com.lanou3g.bean.User&quot;&gt;
    select * from user
&lt;/select&gt;
</code></pre>
<h5 id="resultmap方式">ResultMap方式</h5>
<p>ResultMap方式适用于复杂的结果集映射，比如数据库返回的结果集中的列名和JavaBean无法一一对应，或者对象间存在一对一、一对多关联映射时。</p>
<h6 id="解决数据库列名与java类中属性名不一致的映射问题">解决数据库列名与Java类中属性名不一致的映射问题</h6>
<pre><code class="language-xml">&lt;mapper&gt;
    ...
    &lt;resultMap id=&quot;userMap&quot; type=&quot;user&quot;&gt;
        &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
        &lt;result property=&quot;username&quot; column=&quot;username&quot; /&gt;
        &lt;result property=&quot;lastLoginttime&quot; column=&quot;last_login_time&quot; /&gt;
        &lt;result property=&quot;email&quot; column=&quot;email&quot; /&gt;
        &lt;result property=&quot;nickName&quot; column=&quot;nick_name&quot; /&gt;
    &lt;/resultMap&gt;
    ...
&lt;/mapper&gt;
</code></pre>
<p>在查询语句中将resultType换成resultMap</p>
<pre><code class="language-xml">&lt;select id=&quot;queryAllUser&quot; resultMap=&quot;userMap&quot;&gt;
    select * from user
&lt;/select&gt;
</code></pre>
<blockquote>
<p>其实，如果遇到单纯字段名和属性名不对应的情况，使用别名的方式更简单</p>
</blockquote>
<h6 id="解决一对一映射查询问题">解决一对一映射查询问题</h6>
<h6 id="解决一对多映射查询问题">解决一对多映射查询问题</h6>
<h4 id="动态sql">动态SQL</h4>
<h5 id="条件分支sql">条件分支SQL</h5>
<ul>
<li>if</li>
<li>choose&amp;when&amp;otherwise</li>
</ul>
<h5 id="循环sql">循环SQL</h5>
<ul>
<li>forEach</li>
</ul>
<h5 id="其他特殊sql">其他特殊SQL</h5>
<ul>
<li>where</li>
<li>set</li>
<li>trim</li>
</ul>
<h4 id="批量插入">批量插入</h4>
<h5 id="通过foreach动态sql方式">通过forEach动态SQL方式</h5>
<h6 id="实现原理">实现原理</h6>
<p>forEach批量插入的原理是直接通过forEach动态标签，根据传过来的参数数量动态生成一个很长的SQL语句。一个语句就是一次批量插入。</p>
<p>语句形如：</p>
<pre><code class="language-sql">insert into user (username, age) values
('张三', 10),
('李四', 10),
('王五', 10),
('赵六', 10),
('盖聂', 9000)

# 上面的语句一次会插入5条数据
</code></pre>
<p>我们需要做的就是生成此语句就可以了。</p>
<h6 id="具体做法">具体做法</h6>
<p>Mapper接口</p>
<pre><code class="language-java">int batchInsertUser(List&lt;User&gt; userList);
</code></pre>
<p>Mapper映射文件</p>
<pre><code class="language-xml">&lt;insert id=&quot;batchInsertUser&quot;&gt;
	insert into user (username, age) values
    &lt;forEach collection=&quot;list&quot; item=&quot;user&quot; separator=&quot;,&quot;&gt;
    	(#{user.username}, #{user.age})
    &lt;/forEach&gt;
&lt;/insert&gt;
</code></pre>
<h5 id="通过executorbatch的方式">通过Executor.BATCH的方式</h5>
<h6 id="实现原理-2">实现原理</h6>
<p>这种批量插入在底层的Mapper接口和Mapper映射文件中，都只是一个普通插入单条数据的写法。它通过在上层获取SqlSession时，指定执行类型是批量ExcecutorType.BATCH的方式，实现每次执行完单条插入以后并没有真正写入数据库，只有当调用sqlSession.flushStatement()时，才会将这一批数据一次性写入数据库，从而实现批量操作。</p>
<h6 id="使用步骤">使用步骤</h6>
<ol>
<li>
<p>获取SqlSession时指定执行类型为批量</p>
<pre><code class="language-java">// 获取一个批量执行的sqlSession对象
SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH);
</code></pre>
</li>
<li>
<p>Mapper接口和Mapper映射文件中只需按照单条插入去写方法和SQL语句即可</p>
<p>Mapper接口</p>
<pre><code class="language-java">int insertUser(User user);
</code></pre>
<p>XML映射文件</p>
<pre><code class="language-xml">&lt;insert id=&quot;insertUser&quot;&gt;
    insert into user (nick_name, status, createtime)
    values
    (#{nickName},#{status},#{createtime})
&lt;/insert&gt;
</code></pre>
</li>
<li>
<p>空置批量的大小，在够一批数据时，调用<code>sqlSession.flushStatement()</code>去整体往数据库写一次</p>
<pre><code class="language-java">int batchSize = 100;
int count = 0;
List&lt;BatchResult&gt; resultList = new ArrayList&lt;&gt;();
for(User user : userList) {
    // ExecutorType.Batch方式这里返回的不是影响的条数，具体获取方法参见下面代码
    mapper.insertUser(user);
    count++;
    if(count % batchSize == 0) {
        resultList.addAll(sqlSession.flushStatements());
    }
}
if(count % batchSize != 0) {
    resultList.addAll(sqlSession.flushStatements());
}
</code></pre>
</li>
<li>
<p>获取影响的条数</p>
<p>这种方式获取影响条数没有那么直接，需要去API返回的BatchResult对象中读取updateCounts方法才能拿到。</p>
<pre><code class="language-java">int rows = 0;
for(BatchResult batchResult : resultList) {
    int[] updateCounts = batchResult.getUpdateCounts();
    for(int updateCount : updateCounts) {
        rows += updateCount;
    }
}
System.out.println(&quot;批量插入成功，响应的行数：&quot; + rows);
</code></pre>
</li>
</ol>
<h4 id="缓存">缓存</h4>
<h5 id="一级缓存本地缓存">一级缓存（本地缓存）</h5>
<p>Mybatis的一级缓存是指Session缓存。一级缓存的作用域默认是一个SqlSession。Mybatis默认开启一级缓存。<br>
也就是在同一个SqlSession中，执行相同的查询SQL，第一次会去数据库进行查询，并写到缓存中；<br>
第二次以后是直接去缓存中取。<br>
当执行SQL查询中间发生了增删改的操作，MyBatis会把SqlSession的缓存清空。</p>
<blockquote>
<p>问题： 如果增删改的表和缓存的表是毫不相干的两个表，是否会清空缓存？</p>
</blockquote>
<h6 id="测试方法">测试方法</h6>
<ol>
<li>我们在一个 sqlSession 中，对 User 表根据id进行两次查询，查看他们发出sql语句的情况</li>
</ol>
<pre><code class="language-java">@Test
public void testSelectOrderAndUserByOrderId(){
    //根据 sqlSessionFactory 产生 session
    SqlSession sqlSession = sessionFactory.openSession();
    String statement = &quot;one.to.one.mapper.OrdersMapper.selectOrderAndUserByOrderID&quot;;
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
    //第一次查询，发出sql语句，并将查询的结果放入缓存中
    User u1 = userMapper.selectUserByUserId(1);
    System.out.println(u1);
     
    //第二次查询，由于是同一个sqlSession,会在缓存中查找查询结果
    //如果有，则直接从缓存中取出来，不和数据库进行交互
    User u2 = userMapper.selectUserByUserId(1);
    System.out.println(u2);
     
    sqlSession.close();
}
</code></pre>
<ol start="2">
<li>同样是对user表进行两次查询，只不过两次查询之间进行了一次update操作。</li>
</ol>
<pre><code class="language-java">@Test
public void testSelectOrderAndUserByOrderId(){
    //根据 sqlSessionFactory 产生 session
    SqlSession sqlSession = sessionFactory.openSession();
    String statement = &quot;one.to.one.mapper.OrdersMapper.selectOrderAndUserByOrderID&quot;;
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
    //第一次查询，发出sql语句，并将查询的结果放入缓存中
    User u1 = userMapper.selectUserByUserId(1);
    System.out.println(u1);
     
    //第二步进行了一次更新操作，sqlSession.commit()
    u1.setSex(&quot;女&quot;);
    userMapper.updateUserByUserId(u1);
    sqlSession.commit();
     
    //第二次查询，由于是同一个sqlSession.commit(),会清空缓存信息
    //则此次查询也会发出 sql 语句
    User u2 = userMapper.selectUserByUserId(1);
    System.out.println(u2);
     
    sqlSession.close();
}
</code></pre>
<h5 id="如何禁用一级缓存">如何禁用一级缓存</h5>
<ul>
<li>在映射文件中给对应的select标签上添加<code>flushCache=&quot;true&quot;</code>属性</li>
<li>在核心配置文件中将localCacheScope设置成STATEMENT（默认值是SESSION）</li>
</ul>
<h5 id="二级缓存全局缓存">二级缓存（全局缓存）</h5>
<h6 id="什么是二级缓存">什么是二级缓存？</h6>
<p>Mybatis中二级缓存相比一级（本地）缓存来说是一个作用域更大的缓存方案。 二级缓存的作用域可以跨多个SqlSession，只要是同一个namespace下的mapper映射文件都可以共享缓存。但是不能跨SqlSessionFactory。</p>
<p>Mybatis二级缓存需要手动开启。</p>
<h6 id="开启二级缓存的方法">开启二级缓存的方法</h6>
<p>1.在 SqlMapConfig.xml 文件开启二级缓存</p>
<pre><code class="language-xml">&lt;settings&gt; 
    &lt;!-- 开启全局二级缓存的支持 --&gt;  
    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; 
&lt;/settings&gt; 
</code></pre>
<p>2.配置相关的 Mapper 映射文件 (因为二级缓存就是针对特定的mapper namespace的)</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; 
&lt;!DOCTYPE mapper     
PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;     
&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; 
&lt;mapper namespace=&quot;com.itheima.dao.IUserDao&quot;&gt;  
    &lt;!-- 开启二级缓存的支持 --&gt;  
    &lt;cache /&gt;
&lt;/mapper&gt;
</code></pre>
<blockquote>
<p><cache>标签表示当前这个 mapper 映射将使用二级缓存，能否命中二级缓存就看多次查询是否属于同一个namespace。</p>
</blockquote>
<ol start="3">
<li>设置某个特定的查询语句不用二级缓存</li>
</ol>
<pre><code class="language-xml">&lt;!-- 根据 id 查询 --&gt; 
&lt;select id=&quot;findById&quot; resultType=&quot;user&quot; parameterType=&quot;int&quot; useCache=&quot;false&quot;&gt;  
    select * from user where id = #{uid} 
&lt;/select&gt; 
</code></pre>
<blockquote>
<p>注意： 如果mapper文件中没有开启 <cache /> 仅在语句上添加useCache=&quot;true&quot;是无法开启二级缓存的。这个属性本意是用来关闭特定查询的二级缓存。</p>
</blockquote>
<h6 id="二级缓存注意事项">二级缓存注意事项</h6>
<blockquote>
<p>当我们在使用二级缓存时，所缓存的类一定要实现 java.io.Serializable 接口，这种就可以使用序列化 方式来保存对象。</p>
</blockquote>
<pre><code class="language-java">public class User implements Serializable { }
</code></pre>
<h4 id="mybatis逆向工程">Mybatis逆向工程</h4>
<h2 id="spring与mybatis整合">Spring与Mybatis整合</h2>
<ol>
<li>
<p>加入依赖</p>
<pre><code class="language-xml">&lt;!-- mybatis-spring整合依赖，这个是最主要的一个依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
    &lt;version&gt;2.0.1&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- Spring和数据源相关依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid&lt;/artifactId&gt;
    &lt;version&gt;1.1.20&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>在Spring bean配置文件中配置Mybatis、Spring整合bean  SqlSessionFactoryBean</p>
<pre><code class="language-xml">&lt;!-- 配置整合bean --&gt;
&lt;bean id=&quot;sessionFactoryBean&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
    &lt;!-- 数据源是必要参数 --&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
    &lt;!-- Mybatis核心配置文件其实大多数情况下都可以省略，通过指定属性可以间接设置核心配置文件中的参数 --&gt;
    &lt;!--&lt;property name=&quot;configLocation&quot; value=&quot;mybatis_conf.xml&quot; /&gt;--&gt;

    &lt;!-- 省略mybatis核心配置文件后，可以通过类似下面这些特定属性，设置mybatis参数 --&gt;
    &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.lanou3g.mybatis.spring.bean&quot; /&gt;
    &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot; /&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>在Spring bean配置文件中开启Mybatis Mapper扫描</p>
<ol>
<li>
<p>需要使用mybatis schema</p>
<p>配置方法，在bean配置文件的头部添加</p>
<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mybatis=&quot;http://mybatis.org/schema/mybatis-spring&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd
        http://mybatis.org/schema/mybatis-spring
        http://mybatis.org/schema/mybatis-spring.xsd&quot;&gt;
</code></pre>
</li>
<li>
<p>开启Mybatis Mapper扫描</p>
<p>开启Mybatis Mapper扫描的作用是：告诉Mybatis要创建哪个包下接口的实现类，并以bean的方式加入到SpringIOC容器中</p>
<pre><code class="language-xml">&lt;!-- 开启Mapper扫描，Mybatis会创建将此包下的接口的实现类，并以bean的方式加入到SpringIOC容器中 --&gt;
&lt;mybatis:scan base-package=&quot;com.lanou3g.mybatis.spring.mapper&quot; /&gt;
</code></pre>
</li>
</ol>
</li>
<li>
<p>创建实体类、mapper映射文件、Mapper接口（可以通过Mybatis逆向工程直接生成）</p>
<p>Mapper接口</p>
<pre><code class="language-java">@Repository	//此注解不是必须的，因为MessageMapper类的实现类是由Mybatis创建并放到ioc容器中的，不是由Spring来创建的。
public interface MessageMapper {
    int insert(Message record);
    List&lt;Message&gt; selectAll();
}
</code></pre>
<p>实体类、映射文件 略</p>
</li>
<li>
<p>将Mapper接口用Spring自动注入的方式注入到需要的地方使用</p>
<p>MessageService.java</p>
<pre><code class="language-java">@Service
public class MessageService {
    @Autowired
    MessageMapper messageMapper;
    public List&lt;Message&gt; queryAllMessage() {
        return messageMapper.selectAll();
    }
}
</code></pre>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringMVC]]></title>
        <id>https://zjt-zjt.github.io/post/springmvc-xue-xi-bi-ji</id>
        <link href="https://zjt-zjt.github.io/post/springmvc-xue-xi-bi-ji">
        </link>
        <updated>2019-03-08T13:28:02.000Z</updated>
        <summary type="html"><![CDATA[<!-- SpringMVC 第一天 -->
<h2 id="mvc设计模式">MVC设计模式</h2>
<p>其实在之前JavaWeb阶段我们已经接触到了MVC模式。</p>
<p>MVC里面的M指的的Model（通常包含bean、dao(mapper)、service）；V指的是View，视图层，视图层主要的技术（JSP、HTML、FreeMaker、Themeleaf）；C指的是Controller，控制层。控制层不负责具体数据、逻辑的处理和运算，它只负责将Model层的结果返回给对应的视图层去展示。</p>
]]></summary>
        <content type="html"><![CDATA[<!-- SpringMVC 第一天 -->
<h2 id="mvc设计模式">MVC设计模式</h2>
<p>其实在之前JavaWeb阶段我们已经接触到了MVC模式。</p>
<p>MVC里面的M指的的Model（通常包含bean、dao(mapper)、service）；V指的是View，视图层，视图层主要的技术（JSP、HTML、FreeMaker、Themeleaf）；C指的是Controller，控制层。控制层不负责具体数据、逻辑的处理和运算，它只负责将Model层的结果返回给对应的视图层去展示。</p>
<!-- more -->
<p>在JavaWeb阶段， Controller层指的就是Servlet； View层指的就是JSP或者HTML;  Model层指的就是bean、dao、service。</p>
<p>在J2EE阶段，Controller层指的就是SpringMVC、Structs1\2；  View层不变还是主流的页面展示技术; Model层包括bean、mybatis、service。</p>
<h2 id="springmvc的优势">SpringMVC的优势</h2>
<ul>
<li>SpringMVC是一款很轻量级的框架，要使用它的组件我们往往只需要定义一些最简单的Java类，然后添加某些注解就可以了</li>
<li>SpringMVC的参数注入只直接注入到方法中，可以很好的做到不同请求间数据的隔离，而Struts2是注入到类实例变量上，不同的请求可能会覆盖参数。</li>
<li>SpringMVC可以很轻易的和Spring整合，而Struts需要做比较复杂的配置。</li>
</ul>
<h2 id="springmvc简单使用">SpringMVC简单使用</h2>
<ol>
<li>
<p>添加依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>在web.xml中配置DispatcherServlet</p>
<pre><code class="language-xml">&lt;servlet&gt;
    &lt;servlet-name&gt;aa&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;!-- 指定SpringMVC 配置文件位置，DispatcherServlet初始化时会初始化Spring上下文（WebApplicationContext） --&gt;
    &lt;!-- 默认配置文件寻找位置：/WEB-INF/{servlet-name}-servlet.xml，如果名字符合默认寻找规则，可以不指定配置文件路径 --&gt;
    &lt;!--&lt;init-param&gt;
      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
      &lt;param-value&gt;/WEB-INF/aa-servlet.xml&lt;/param-value&gt;
    &lt;/init-param&gt;--&gt;
    &lt;!-- 配置容器启动时初始化DispatcherServlet --&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;aa&lt;/servlet-name&gt;
    &lt;!-- 映射路径配置成/，代表当前Servlet是一个默认Servlet，就是当其他Servlet都无法处理请求时，由默认Servlet出马 --&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;!--    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;--&gt;
  &lt;/servlet-mapping&gt;
</code></pre>
</li>
<li>
<p>配置SpringMVC  dispatcher-servlet.xml</p>
<p>SpringMVC大部分组件都有默认配置，我们一般简单应用只需要指定视图解析器就行了</p>
<p>dispatcher-servlet.xml</p>
<pre><code class="language-xml">&lt;!-- 配置视图解析器，用于将Handler方法中返回的视图名解析成真正可展示的页面 --&gt;
&lt;mvc:view-resolvers&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/&quot; /&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;
&lt;/mvc:view-resolvers&gt;
</code></pre>
</li>
<li>
<p>定义Controller</p>
<p>新建一个普通类，然后添加<code>@Controller</code>注解，就可以了</p>
</li>
<li>
<p>定义请求处理方法(Handler)</p>
<p>在Controller类中定义一个普通的方法，添加<code>@RequestMapping</code>注解就可以了</p>
</li>
</ol>
<h2 id="springmvc主要组件">SpringMVC主要组件</h2>
<h3 id="rootapplicationcontext和servletapplicationcontext">RootApplicationContext和ServletApplicationContext</h3>
<figure data-type="image" tabindex="1"><img src="https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/images/mvc-context-hierarchy.png" alt="父子上下文概念"></figure>
<h4 id="两个applicationcontext的联系和区别">两个ApplicationContext的联系和区别</h4>
<h3 id="视图解析器">视图解析器</h3>
<p>视图解析器的作用是将请求处理方法中的返回值解析成一个真正可以渲染的页面。</p>
<h4 id="常用的视图解析器">常用的视图解析器</h4>
<ul>
<li>
<p>InternalResourceViewResolver</p>
<p>内部资源解析器： 用于将返回值对应到项目路径下的某个可显示的页面。比如方法返回值是index字符串，那么<code>InternalResourceViewResolver</code>解析器会在index前加上指定的前缀，在index后加上指定的后缀来拼接成指向某个视图的路径。</p>
<pre><code class="language-xml">&lt;!-- 配置视图解析器，用于将Handler方法中返回的视图名解析成真正可展示的页面 --&gt;
&lt;mvc:view-resolvers&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/&quot; /&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;
&lt;/mvc:view-resolvers&gt;
</code></pre>
</li>
</ul>
<h3 id="参数传递">参数传递</h3>
<h4 id="页面参数传递到controller">页面参数传递到Controller</h4>
<h5 id="requestparam">@RequestParam</h5>
<p>获取请求参数，包括通过GET请求中的查询参数、POST请求中的参数等</p>
<pre><code class="language-java">@RequestMapping(&quot;/hello&quot;)
public String toHelloPage(@RequestParam String message, Model model) {
	model.addAttribute(&quot;msg&quot;, message);
	return &quot;hello_springmvc&quot;;
}


// 当方法参数名和请求参数不一样时，可以使用注解的参数对应起来
@RequestMapping(&quot;/hello&quot;)
public String toHelloPage(@RequestParam(&quot;message&quot;) String msg, Model model) {
	model.addAttribute(&quot;msg&quot;, message);
	return &quot;hello_springmvc&quot;;
}
</code></pre>
<blockquote>
<p>访问: http://localhost:8080/hello?message=zhangsan 时，message参数会自动注入到方法的message参数中。</p>
</blockquote>
<h5 id="requestheader">@RequestHeader</h5>
<p>获取请求头中的参数，如浏览器默认自带的userAgent就是请求头参数</p>
<pre><code class="language-java">@RequestMapping(&quot;/hello&quot;)
public String toHelloPage(@RequestHeader String userAgent, Model model) {
	model.addAttribute(&quot;msg&quot;, userAgent);
	return &quot;hello_springmvc&quot;;
}


// 当方法参数名和请求头参数不一样时，可以使用注解的参数对应起来
@RequestMapping(&quot;/hello&quot;)
public String toHelloPage(@RequestHeader(&quot;userAgent&quot;) String ua, Model model) {
	model.addAttribute(&quot;msg&quot;, ua);
	return &quot;hello_springmvc&quot;;
}
</code></pre>
<blockquote>
<p>会自动将请求头中的userAgent参数注入到方法中</p>
</blockquote>
<h5 id="pathvariable">@PathVariable</h5>
<p>获取请求地址中的参数，注入到方法参数中</p>
<pre><code class="language-java">@RequestMapping(&quot;/hello/{sname}&quot;)
public String toHelloPage(@PathVariable String sname, Model model) {
	model.addAttribute(&quot;msg&quot;, sname);
	return &quot;hello_springmvc&quot;;
}


// 当方法参数名和请求地址中参数不一样时，可以使用注解的参数对应起来
@RequestMapping(&quot;/hello/{sname}&quot;)
public String toHelloPage(@PathVariable(&quot;sname&quot;) String sn, Model model) {
	model.addAttribute(&quot;msg&quot;, sn);
	return &quot;hello_springmvc&quot;;
}
</code></pre>
<blockquote>
<p>访问：http://localhost:8080/hello/zhangsan  会自动将zhangsan注入到方法的参数中</p>
</blockquote>
<h5 id="requestattribute">@RequestAttribute</h5>
<p>jsp中</p>
<pre><code class="language-jsp">&lt;%
        request.setAttribute(&quot;sname&quot;, &quot;虞姬req&quot;);
        request.getRequestDispatcher(&quot;/param/req_scope&quot;).forward(request, response);
%&gt;
</code></pre>
<p>Controller中</p>
<pre><code class="language-java">/**
  * 请求作用域中的参数的传递
  * @return
  */
@RequestMapping(&quot;/req_scope&quot;)
public String requestScopeParamShow(@RequestAttribute String sname, Model model) {
    model.addAttribute(&quot;sname&quot;, sname);
    model.addAttribute(&quot;type&quot;, &quot;请求作用域参数&quot;);
    return &quot;param_show&quot;;
}

</code></pre>
<blockquote>
<p>获取请求作用域中的参数</p>
</blockquote>
<h5 id="sessionattribute">@SessionAttribute</h5>
<blockquote>
<p>获取Session作用域中的参数，用法和上面请求作用域中使用类似</p>
</blockquote>
<h5 id="cookievalue">@CookieValue</h5>
<p>jsp中代码</p>
<pre><code class="language-jsp">cookie参数传递：&lt;br /&gt;
&lt;%
response.addCookie(new Cookie(&quot;sname&quot;, &quot;yuji_cookie&quot;));
%&gt;
&lt;a href=&quot;/param/cookie&quot;&gt;发起请求&lt;/a&gt;

</code></pre>
<p>Controller中</p>
<pre><code class="language-java">/**
  * Cookie中的参数的传递
  * @return
  */
@RequestMapping(&quot;/cookie&quot;)
public String cookieParamShow(@CookieValue String sname, Model model) {
    model.addAttribute(&quot;sname&quot;, sname);
    model.addAttribute(&quot;type&quot;, &quot;cookie参数&quot;);
    return &quot;param_show&quot;;
}

</code></pre>
<blockquote>
<p>获取Cookie中的指定数据</p>
</blockquote>
<blockquote>
<p>上面这几个注解都是用于在方法的参数上标注，用于获取不同种类的参数</p>
</blockquote>
<h4 id="controller中的数据传递到页面">Controller中的数据传递到页面</h4>
<h5 id="model">Model</h5>
<p>handler方法定义：</p>
<pre><code class="language-java">@RequestMapping(&quot;/show_msg&quot;)
public String showMessage(Model model) {
    model.addAttribute(&quot;msg&quot;, &quot;我是通过model传过来的参数&quot;);
    return &quot;message_page&quot;;
}

</code></pre>
<p>message_page.jsp</p>
<pre><code class="language-jsp">&lt;h1&gt;
    获取后台参数： ${msg}
&lt;/h1&gt;

</code></pre>
<h5 id="modelandview">ModelAndView</h5>
<pre><code class="language-java">/**
 * ModelAndView其实是将数据Model和视图View做了一个封装，底层实现原理一样
 */
@RequestMapping(&quot;/show_msg&quot;)
public ModelAndView showMessage(ModelAndView mv) {
    mv.addObject(&quot;msg&quot;, &quot;我是通过model传过来的参数&quot;);
    mv.setViewName(&quot;message_page&quot;);
    return mv;
}

</code></pre>
<blockquote>
<p>Model和ModelAndView传递的参数本质上也是用请求作用域来实现的，所以仅对请求转发有效。</p>
</blockquote>
<h3 id="视图控制器">视图控制器</h3>
<p>用于通过配置的方式简化我们项目中不含业务逻辑的页面跳转，省去了我们写一个空方法的步骤。</p>
<h4 id="视图控制器的作用和用法">视图控制器的作用和用法</h4>
<p>试想一下，如果我们的工程中有这样的一个需求，比如当用户点了某个链接和按钮的时候，我们需要做一个页面跳转，这个跳转的目标可能是一个公开目录的页面也可能是私有目录（/WEB-INF/下）的页面、还可能是跳转到后台Controller的某个方法中，我们如何实现？</p>
<p>示例：比如我们想将登陆页设置为一个项目默认欢迎页面</p>
<p>方案一：在Controller中添加一个拦截/的handler方法</p>
<pre><code class="language-java">@RequestMapping(&quot;/&quot;)
public String toWelcomePage() {
    return &quot;login&quot;;
}

</code></pre>
<p>方法二：使用视图控制器</p>
<p>在dispatcher-servlet.xml（SpringMVC配置文件）配置中添加</p>
<pre><code class="language-xml">&lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;login&quot; /&gt;

</code></pre>
<ul>
<li>path: 指定要匹配的访问路径</li>
<li>view-name: 返回的逻辑视图名</li>
<li>status-code: 设置响应状态码。(注：不能通过只设置状态码，不设置view-name实现只返回code，没有页面的处理)</li>
</ul>
<blockquote>
<p>view-name不仅可以是逻辑视图名，还可以添加forward、redirect前缀，通过转发或重定向的方式跳转到一个具体的路径，如：&lt;mvc:view-controller path=&quot;/&quot; view-anme=&quot;forward:/WEB-INF/login.jsp&quot; /&gt;</p>
</blockquote>
<!-- SpringMVC 第二天 -->
<h3 id="设置web项目的默认欢迎页">设置Web项目的默认欢迎页</h3>
<ul>
<li>
<p>在web.xml中使用<welcome-file-list>标签指定</p>
</li>
<li>
<p>使用上面提到的视图控制器</p>
<pre><code class="language-xml">&lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;逻辑视图名&quot; /&gt;
&lt;!-- 当工程中存在Tomcat默认欢迎页同名文件时此种方式可能失效，比如index.html、index.jsp、index.htm --&gt;

</code></pre>
</li>
</ul>
<h3 id="静态资源处理">静态资源处理</h3>
<pre><code class="language-xml">&lt;!-- 针对静态资源的处理 --&gt;
    &lt;!-- http://localhost:8080/static/css/index.css --&gt;
&lt;mvc:resources mapping=&quot;/static/**&quot; location=&quot;/static/&quot; /&gt;

</code></pre>
<h3 id="重定向和转发">重定向和转发</h3>
<h4 id="在servlet实现重定向和转发">在Servlet实现重定向和转发：</h4>
<p>重定向：response.sendRedirect(&quot;xxx.jsp&quot;);</p>
<p>转发： request.getRequestDispatcher(&quot;xxx.jsp&quot;).forward(request, response);</p>
<h4 id="在springmvc中">在SpringMVC中</h4>
<h5 id="请求转发有三种方式">请求转发有三种方式</h5>
<ul>
<li>在Handler方法中直接返回逻辑视图名称</li>
<li>在Handler方法中返回&quot;forward:路径&quot;</li>
<li>在Handler方法中返回InternalResourceView对象</li>
</ul>
<blockquote>
<p>其中第二种和第三种作用一样， 都是将路径用请求转发的方式跳转，返回的路径时不经过视图解析器处理的；而第一种虽然也是通过请求转发方式跳转，但是返回值会作为逻辑视图名称，经过视图解析器处理后，才渲染。</p>
</blockquote>
<h5 id="重定向有两种方式">重定向有两种方式</h5>
<ul>
<li>在Handler方法中返回&quot;redirect:路径&quot;</li>
<li>在Handler方法中返回RedirectView对象</li>
</ul>
<blockquote>
<p>这两种方法效果一样。 注意使用重定向的方式跳转页面，Model中的数据就无法带到页面了（因为Model底层也是用请求作用域来传递参数的）。</p>
</blockquote>
<h3 id="restfull服务接口开发">RESTFull服务接口开发</h3>
<p>SpringMVC给我们提供了一系列的注解用于支持RESTFull风格的服务开发</p>
<h4 id="常用restfull注解">常用RESTFull注解</h4>
<ul>
<li>
<p><code>@RestController</code></p>
<p>该注解本身是一个组合注解，由<code>@Controller</code>和<code>@ResponseBody</code>两个注解组成，所以拥有这两个注解的作用。 在类上声明后，该类会变成一个Controller类，同时，方法的返回值会作为响应体经过消息转换器直接响应给客户端，而不会将其作为视图渲染。</p>
<pre><code class="language-java">@RestController // 这个注解其实是组合了下面两个注解的作用
//@Controller
//@ResponseBody
public class UserRestController {

}

</code></pre>
</li>
<li>
<p><code>@GetMapping</code> :</p>
<p>作用： 申明当前handler方法只匹配GET请求</p>
<p>使用示例</p>
<pre><code class="language-java">@GetMapping(&quot;/{id}&quot;)
public User getUserById(@PathVariable Integer id) {
    return userService.findById(id);
}

</code></pre>
</li>
<li>
<p><code>@PostMapping</code>: 申明当前handler方法只匹配POST请求</p>
</li>
<li>
<p><code>@DeleteMapping</code>: 申明当前handler方法只匹配DELETE请求</p>
</li>
<li>
<p><code>@PutMapping</code>: 申明当前handler方法只匹配PUT请求</p>
</li>
</ul>
<blockquote>
<p>上面四个注解分别对应HTTP的一种请求方法，使用方法类似。</p>
</blockquote>
<p>上面四个注解其实是一种快捷注解， 等效于使用下面代码：</p>
<pre><code class="language-java">@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.GET)
@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.POST)
@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.PUT)
@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.DELETE)

</code></pre>
<ul>
<li>@PathVariable: 获取请求地址中的变量，注入到方法参数中</li>
</ul>
<h4 id="返回json格式的数据-消息转换器">返回JSON格式的数据 —— 消息转换器</h4>
<h5 id="消息转换器是什么">消息转换器是什么</h5>
<p>之前我们在写普通Controller时，handler方法的返回值要是就是一个String（逻辑视图名），要么就是一个ModelAndView、View对象。</p>
<p>而我们使用了RestController之后，方法的返回值已经不会被作为视图去渲染了，这时候我们的方法其实可以返回任意类型的数据。这些数据会直接通过响应体以流的方式返回给客户端。</p>
<p>我们知道Java中的对象是不能直接用流的方式读取的，需要序列化。比如我们的handler方法返回了一个User类型，SpringMVC就不知道如果将这个类型返回给客户端了。这时就需要我们通过配置消息转换器来完成这种类型对象的返回处理。 而在RESTFull服务中，对象绝大部分传递方式就是通过JSON格式。</p>
<h5 id="如何配置一个转换json格式的消息转换器">如何配置一个转换JSON格式的消息转换器</h5>
<ul>
<li>
<p>使用SpringMVC默认的Jackson库</p>
<ol>
<li>
<p>引入依赖</p>
<pre><code class="language-xml">&lt;!-- jackson依赖，用于将handler方法返回的对象直接转换成JSON数据 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;version&gt;2.9.7&lt;/version&gt;
&lt;/dependency&gt;

</code></pre>
</li>
<li>
<p>开启mvc注解支持</p>
<pre><code class="language-xml">&lt;mvc:annotation-driven /&gt;

</code></pre>
</li>
<li>
<p>定义Controller类</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/user&quot;)
public class UserRestController {
    
    @GetMapping(&quot;/{id}&quot;)
    public User getUserById(Integer id) {
        return userService.findById(id);
    }
    
}

</code></pre>
</li>
</ol>
<blockquote>
<p>Jackson是SpringMVC默认的JSON格式消息转换器， 所以在不配置额外转json参数时，我们可以直接只引入jackson依赖，再开启mvc直接支持就可以了。而第三方的转换库如FastJSON就必须显示配置MessageConverter</p>
</blockquote>
</li>
<li>
<p>使用阿里巴巴的FastJSON库</p>
<ol>
<li>
<p>引入依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
     &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
     &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
     &lt;version&gt;1.2.57&lt;/version&gt;
&lt;/dependency&gt;

</code></pre>
</li>
<li>
<p>配置MessageConverter</p>
<pre><code class="language-xml">&lt;mvc:annotation-driven&gt;
    &lt;mvc:message-converters&gt;
        &lt;bean class=&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;&gt;
            &lt;property name=&quot;defaultCharset&quot; value=&quot;UTF-8&quot; /&gt;
            &lt;property name=&quot;fastJsonConfig&quot;&gt;
                &lt;!-- 设置转换JSON的参数 --&gt;
                &lt;bean class=&quot;com.alibaba.fastjson.support.config.FastJsonConfig&quot;&gt;
                    &lt;property name=&quot;dateFormat&quot; value=&quot;yyyy-MM-dd HH:mm:ss&quot; /&gt;
                &lt;/bean&gt;
            &lt;/property&gt;
            &lt;property name=&quot;supportedMediaTypes&quot;&gt;
            &lt;!-- 指定转换完JSON后返回的响应头和编码，添加text/html是为了处理在IE下application/json会弹出下载框问题 --&gt;
                &lt;list&gt;
                    &lt;!--&lt;value&gt;text/html;charset=UTF-8&lt;/value&gt;--&gt;                
                    &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt;
                &lt;/list&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/mvc:message-converters&gt;
&lt;/mvc:annotation-driven&gt;

</code></pre>
</li>
<li>
<p>定义Controller类</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/user&quot;)
public class UserRestController {
    
    @GetMapping(&quot;/{id}&quot;)
    public User getUserById(Integer id) {
        return userService.findById(id);
    }
    
}

</code></pre>
</li>
</ol>
</li>
</ul>
<h4 id="通过网页模拟restfull请求">通过网页模拟RESTFull请求</h4>
<p>通过SpringMVC给我们提供的一个过滤器，我们可以用表单模拟各种RESTFull的请求，使用方法如下：</p>
<ol>
<li>
<p>在web.xml中添加过滤器</p>
<pre><code class="language-xml">&lt;filter&gt;
    &lt;filter-name&gt;httpMethodFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;httpMethodFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;

</code></pre>
</li>
<li>
<p>在表单中添加name为_method的hidden域，并将表单的method设置为post</p>
<pre><code class="language-html">&lt;!-- 使用表单模拟发起一个DELETE请求，删除user表中id为57的数据 --&gt;
&lt;form action=&quot;/user/57&quot; method=&quot;post&quot;&gt;
    &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;delete&quot; /&gt;
    &lt;input type=&quot;number&quot; name=&quot;id&quot; /&gt;
    &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;
    &lt;input type=&quot;submit&quot; /&gt;
&lt;/form&gt;

</code></pre>
</li>
</ol>
<blockquote>
<p>由于RESTFull请求通常发生在服务于服务之间的调用，所以有些请求用浏览器不太好模拟，建议使用专业的网络测试工具postman来进行测试。</p>
</blockquote>
<h4 id="resttemplate工具类">RestTemplate工具类</h4>
<p>SpringMVC帮我们封装的一个Rest请求工具，可以使用一个URI地址发起网络请求，并且将结果封装成一个指定的对象。</p>
<h3 id="处理请求乱码">处理请求乱码</h3>
<p>SpringMVC给我们提供了一个专门用来解决post请求乱码的过滤器，我们只需将其配置到web.xml中，就可以避免post请求乱码，免去了我们自己写过滤器的麻烦</p>
<p>在web.xml中</p>
<pre><code class="language-xml">&lt;!-- 解决POST请求乱码 --&gt;
&lt;filter&gt;
    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;forceEncoding&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;

</code></pre>
<blockquote>
<p>注意： 如果项目中配置了多个过滤器，建议将此过滤器放到所有过滤器的最上面。</p>
</blockquote>
<h3 id="在springmvc方法中支持的参数">在SpringMVC方法中支持的参数</h3>
<p>SpringMVC的handler方法中支持诸如很多特殊类型的参数，常用的有</p>
<h5 id="注入原生servlet对象">注入原生Servlet对象</h5>
<ul>
<li>javax.servlet.ServletRequest</li>
<li>javax.servlet.ServletResponse</li>
<li>javax.serlvet.http.HttpSession</li>
</ul>
<h5 id="以流的方式读取请求体-以流的方式响应到客户端">以流的方式读取请求体、以流的方式响应到客户端</h5>
<ul>
<li><s>java.io.InputStream、java.io.Reader</s></li>
<li><s>java.io.OutputStream、java.io.Writer</s></li>
</ul>
<h5 id="读取请求体和请求头数据">读取请求体和请求头数据</h5>
<ul>
<li>HttpEntity</li>
</ul>
<h5 id="向页面传参">向页面传参</h5>
<ul>
<li>java.util.Map，org.springframework.ui.Model、org.springframework.ui.ModelMap</li>
</ul>
<!-- SpringMVC 第三天 -->
<h3 id="文件上传">文件上传</h3>
<h4 id="说明">说明</h4>
<p>在Java中，主流的文件上传方式有两种，分别是通用文件上传(commons-fileupload)和Servlet3.0方式的文件上传。SpringMVC分别对着两种方式都做了支持。</p>
<ul>
<li>CommonsMultipartResolver</li>
<li>StandardServletMultipartResolver</li>
</ul>
<blockquote>
<p>除此之外SpringMVC对文件上传的接口做了统一的封装，使用<code>MultipartFile</code>接口代替了通用上传中的<code>FileItem</code>和Servlet3.0中的<code>Part</code>，使得开发人员在业务代码中可以使用统一的接口处理，而不用管底层用的是哪种文件上传实现方式。</p>
</blockquote>
<h4 id="基于apache-fileupload通用文件上传包">基于Apache Fileupload通用文件上传包</h4>
<ol>
<li>
<p>添加依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
    &lt;version&gt;1.4&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-io&lt;/groupId&gt;
    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
    &lt;version&gt;2.6&lt;/version&gt;
&lt;/dependency&gt;

</code></pre>
</li>
<li>
<p>在SpringMVC配置文件中添加MultipartResolver文件上传解析器</p>
<pre><code class="language-xml">&lt;!-- 配置基于apache fileupload的通用文件上传器（注意：id属性不可省略） --&gt;
&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
    &lt;!-- 指定文件上传编码 --&gt;
    &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot; /&gt;
&lt;/bean&gt;

</code></pre>
</li>
<li>
<p>在Controller中编写文件上传逻辑代码</p>
<pre><code class="language-java">@RequestMapping(&quot;/upload&quot;)
public String upload(@RequestParam(&quot;myFile&quot;) MultipartFile file, HttpServletRequest req, Model model) {
    try {
        // 使用SpringMVC给我们提供的工具类获取项目中upload文件夹在硬盘上的绝对路径
        String uploadPath = WebUtils.getRealPath(req.getServletContext(), &quot;/upload/&quot;);
        // 将上传的文件写到上传目录
        file.transferTo(new File(uploadPath+file.getOriginalFilename()));
    } catch (IOException e) {
        e.printStackTrace();
    }
}

</code></pre>
</li>
</ol>
<h4 id="基于servlet30标准api文件上传">基于Servlet3.0标准API文件上传</h4>
<ol>
<li>
<p>开启Servlet文件上传支持</p>
<p>web.xml</p>
<pre><code class="language-xml">&lt;servlet&gt;
    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;!-- 开启Servlet文件上传支持 --&gt;
    &lt;multipart-config /&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

</code></pre>
</li>
<li>
<p>在SpringMVC中配置MultipartResolver</p>
<pre><code class="language-xml">&lt;!-- 配置基于Servlet3.0文件上传器（注意：id属性不可省略） --&gt;
&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.support.StandardServletMultipartResolver&quot; /&gt;

</code></pre>
</li>
<li>
<p>在Controller中编写文件上传逻辑代码</p>
<blockquote>
<p>实现方式同通用上传代码一样。</p>
</blockquote>
</li>
</ol>
<h4 id="文件名上传乱码问题">文件名上传乱码问题</h4>
<ul>
<li>
<p>使用通用上传方式的解决方法</p>
<p>在配置的CommonsMultipartResolver bean中注入属性</p>
<pre><code class="language-xml">&lt;!-- 配置基于apache fileupload的通用文件上传器（注意：id属性不可省略） --&gt;
&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
    &lt;!-- 指定文件上传编码 --&gt;
    &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot; /&gt;
&lt;/bean&gt;

</code></pre>
</li>
<li>
<p>使用Servlet3.0标准上传方式的解决方法</p>
<p>通过配置SpringMVC提供的编码过滤器解决</p>
<p>web.xml</p>
<pre><code class="language-xml">&lt;filter&gt;
    &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;forceEncoding&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;

</code></pre>
<blockquote>
<p>本质上还是设置请求的编码 request.setCharacterEncoding(&quot;UTF-8&quot;);</p>
</blockquote>
</li>
</ul>
<h3 id="拦截器">拦截器</h3>
<h4 id="拦截器-vs-过滤器">拦截器 VS 过滤器</h4>
<p>过滤器是Servlet规范中提供的一项技术。不依赖于任何第三方框架。它的作用主要用来做两件事： 加工请求、过滤请求。</p>
<p>拦截器是SpringMVC自己封装的一项基于Handler拦截的结束。也就是说只有在SpringMVC框架里面才有拦截器的概念。拦截器拦截的对象是Handler。它的全称是 HandlerInterceptor。</p>
<p>加上拦截器以后，请求处理流程：  request -&gt; DispatcherServlet -&gt; HandlerMapping -&gt; HandlerExecutionChain(包含了目标handler和若干个拦截器) -&gt; HandlerAdapter -&gt; 循环调用HandlerExecutionChain对象中所有拦截器的prehandler方法 -&gt; 如果preHandler返回false，那么handler将不会被调用。反之，才会正常调用。</p>
<h4 id="如何使用拦截器">如何使用拦截器</h4>
<h5 id="定义拦截器类">定义拦截器类</h5>
<p>新建一个类实现HandlerInterceptor接口</p>
<pre><code class="language-java">/**
 * 定义拦截器步骤：
 *      1. 定义一个普通类，实现HandlerInterceptor接口
 *      2. 按需实现接口中的方法
 *      3. 在SpringMVC配置文件中通过&lt;mvc:interceptors&gt;&lt;/mvc:interceptors&gt;配置拦截器
 */
public class NotAllowedInterceptor implements HandlerInterceptor {

    /**
     * 此回调方法在执行Handler之前被调用
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println(&quot;进入NotAllowedInterceptor, 凡是我能拦截到的请求，一律不准通过!&quot;);
        return false;
    }

    /**
     * 此回调方法在执行Handler之后被调用
     * @param request
     * @param response
     * @param handler
     * @param modelAndView
     * @throws Exception
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {

    }

    /**
     * 此回调方法在DispatcherServlet最终响应之前被调用
     * @param request
     * @param response
     * @param handler
     * @param ex
     * @throws Exception
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {

    }
}

</code></pre>
<h5 id="配置拦截器">配置拦截器</h5>
<h6 id="全局拦截器">全局拦截器</h6>
<pre><code class="language-xml">&lt;mvc:interceptors&gt;
    &lt;!-- 这种方式配置的拦截器会拦截所有请求 --&gt;
    &lt;bean class=&quot;com.lanou3g.springmvc.interceptor.NotAllowedInterceptor&quot; /&gt;
&lt;/mvc:interceptors&gt;

</code></pre>
<h6 id="拦截指定请求的拦截器">拦截指定请求的拦截器</h6>
<pre><code class="language-xml">&lt;mvc:interceptors&gt;
    &lt;mvc:interceptor&gt;
        &lt;!-- 拦截的请求 --&gt;
        &lt;mvc:mapping path=&quot;/admin/**&quot; /&gt;
        &lt;!-- 不拦截的请求 --&gt;
        &lt;mvc:exclude-mapping path=&quot;/intercepor/**&quot;/&gt;
        &lt;!-- 配置我们定义的实现了HandlerInterceptor接口的类 --&gt;
        &lt;bean class=&quot;com.lanou3g.springmvc.interceptor.NotAllowedInterceptor&quot; /&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;

</code></pre>
<h3 id="ssm整合">SSM整合</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://zjt-zjt.github.io/post/hello-gridea</id>
        <link href="https://zjt-zjt.github.io/post/hello-gridea">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[集合框架]]></title>
        <id>https://zjt-zjt.github.io/post/ji-he-kuang-jia</id>
        <link href="https://zjt-zjt.github.io/post/ji-he-kuang-jia">
        </link>
        <updated>2018-08-02T11:20:30.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p>集合：简单的说，集合就是一种容器。</p>
<p>集合作为一种容器，里面可以存放内容，存放的每个内容称为是<strong>元素</strong>（element）。</p>
<p>在整个集合框架里一共有2个大类容器：Collection和Map</p>
<h2 id="collection容器interface">Collection容器（interface）</h2>
<p>Collection是元素类容器的根<strong>接口</strong>。</p>
<h4 id="什么是容器">什么是容器</h4>
<p>容器是一个用于存放东西的物件。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。0</p>
<h4 id="容器应该具备什么功能呢什么样的物件叫容器">容器应该具备什么功能呢？（什么样的物件叫容器）</h4>
<ol>
<li>
<p>可以存东西</p>
<p><strong>add(E element)</strong>  //往容器里添加一个元素。元素可以是任意类型（整数，字符串，自定义类，容器）</p>
<p>addAll(Collection c) //往容器里添加多个元素。参数是一个容器，这个方法会把容器里的元素逐一添加进来</p>
</li>
<li>
<p>查看</p>
<p><strong>size()</strong>  //查看容器中包含多少元素</p>
<p><strong>contains(Object o)</strong> //查看是否包含某个元素</p>
<p>containsAll(Collection c) //查看是否包含某些元素</p>
<p>isEmpty() //是不是一个空容器</p>
</li>
<li>
<p>可以提取(删除)东西</p>
<p>clear()  //清空容器</p>
<p><strong>remove(Object o)</strong> //移除一个元素</p>
<p>removeAll(Collection c) //移除参数容器中包含的元素</p>
</li>
<li>
<p>其他</p>
<p>equals(Collection c) //判断是否个另外一个容器相等。</p>
<p>toArray() //把容器转换为数组</p>
</li>
</ol>
<h3 id="listinterface">List（interface）</h3>
<p>list的英文含义是：列表。</p>
<p>list用于定义什么是有序容器。有序容器是容器的一种。</p>
<p>List是一个接口，它有一个父接口Collection。<strong>List相比于Collection多了下标的概念</strong>。用标可以去访问元素。</p>
<p>围绕下标提供了一堆方法：</p>
<ol>
<li>
<p>添加元素</p>
<p><strong>add(int index, E element)</strong> //在指定的位置添加一个元素<br>
addAll(int index, Collection c) //在指定的位置添加多个元素</p>
<p>删除元素</p>
<p><strong>remove(int index)</strong> //移除指定位置的元素</p>
</li>
<li>
<p>获得子列表</p>
<p>subList(int fromIndex, int toIndex) //获取一个子列表  [formIndex, toIndex)</p>
</li>
<li>
<p>更新元素</p>
<p>set(int index, E element)// 把指定下标的元素更新为指定内容</p>
</li>
<li>
<p>获取元素的位置</p>
<p>indexOf(Object o) //获取指定元素的下标（正着查）</p>
<p>lastIndexOf(Object o)//获取指定元素的下标（倒着查）</p>
<p><strong>get(int index)</strong> //获取指定下标的元素</p>
</li>
</ol>
<h3 id="list的实现类">List的实现类</h3>
<h4 id="arraylist">ArrayList</h4>
<p>ArrayList是List的实现类。既然是实现类，说明ArrayList实现了List中定义的所有方法。</p>
<ol>
<li>
<p>如何创建一个ArrayList对象</p>
<p>ArrayList()   //创建一个初始容量为10的列表。列表里尚未存放任何元素。</p>
<p>ArrayList(int capacity) //创建一个指定初始容量的列表。列表里尚未存放任何元素</p>
<blockquote>
<p>初始容量: 列表刚创建时给定的容量。</p>
<p>Collection是个容器，这个容器与之前学过的数组不同，数组是定长的容器，不能减少容量也不能增加容量。但是Collection是一个变长的容器，空间不够的时候可以扩容。</p>
</blockquote>
<p>ArrayList(Collection c) //创建一个包含参数中全部元素的列表。</p>
</li>
<li>
<p>ArrayList的使用</p>
<p>增删改查（API参考 List）</p>
</li>
</ol>
<blockquote>
<p>在创建ArrayList的时候必须指定元素的类型。例如：ArrayList<String></p>
<p>一旦指定ArrayList存放什么类型的数据，以后取元素的时候，无需进行类型转换。</p>
</blockquote>
<ol start="3">
<li>
<p>遍历ArrayList</p>
<p>假定ArrayList内容如下：</p>
</li>
</ol>
<pre><code class="language-java">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
list.add(&quot;张三&quot;);
list.add(&quot;李四&quot;);
list.add(&quot;王五&quot;);
list.add(&quot;赵六&quot;);
</code></pre>
<p>遍历ArrayList的方法有很多，常用方式如下：</p>
<p>一、使用for循环遍历</p>
<pre><code class="language-java">for(int i = 0; i &lt; list.size(); i++){
    String str = list.get(i);
    System.out.println(str);
}
</code></pre>
<blockquote>
<p>使用list.size()获取元素个数， 从下标0开始循环到结束。通过list.get(i) 获取每个元素，达到遍历的效果。</p>
</blockquote>
<p><strong>二、使用迭代器遍历（推荐）</strong></p>
<pre><code class="language-java">Iterator&lt;String&gt; it = list.iterator();//获取迭代器（迭代器会包含list中所有的元素）
while(it.hasNext()){
    String str = it.next();//获取迭代器中的元素，next执行完，迭代器会指向下一个元素。
    System.out.println(str);
}
</code></pre>
<blockquote>
<p>Iterator是一个接口，规定了迭代器应该具有什么功能（hasNext(), next(), remove()）。</p>
<p>hasNext()方法：用于查看是否还有元素。如果迭代器中还有元素，返回true，如果没有元素了，返回false。</p>
<p>next()：获取当前迭代的元素，迭代器指向下一个元素。</p>
<p>remove(): 删除当前迭代到的元素。</p>
</blockquote>
<p>三、使用for..each遍历元素</p>
<pre><code class="language-java">for(String str : list){
    System.out.println(str);//str就是被遍历到的元素。
}
</code></pre>
<blockquote>
<p>for...each是for循环的增强版，有些语言叫for..in</p>
<p>for...each的本质是通过迭代器遍历元素。可通过XJad反编译工具反编译.class文件查看源码。</p>
</blockquote>
<h4 id="arraylist的优势和劣势">ArrayList的优势和劣势</h4>
<p>ArrayList的底层实现是数组，数组最大特点：数据的内存空间是连续的，所以根据下标查找元素是非常非常快。</p>
<p>弊端增加和删除慢，如果要删除下标为0的元素，实际上是通过循环，把下标为1的赋值给下标为0，把下标为2的赋值给下标为1的，以此类推，直到所有元素位置正确。</p>
<p>如果要在下标为0的位置添加一个元素，它也是通过循环实现的，最大下标的元素赋值给最大下标加1的位置，第2大的下标的元素赋值给最大下标，以此类推第0个元素赋值给第1个元素，新元素覆盖下标为0的元素。</p>
<h3 id="list的另外一个实现类-linkedlist">List的另外一个实现类 LinkedList</h3>
<p>LinkedList使用方式同ArrayList。</p>
<p>LinkedList与ArrayList不同，LinkedList底层靠的是双向链表在存储数据。</p>
<p>链表的特点：增删快，查询慢（需要遍历）。</p>
<h3 id="list的另外一个实现类-vector">List的另外一个实现类 Vector</h3>
<p>实现方式和ArrayList几乎一模一样，Vector所有的方法是线程安全的。在线程里，如果不同的线程在访问同一个List（Vector），不会出现数据紊乱（内部加了锁，一个方法执行的时候，其他的方法等待，执行完以后，其他方法才开始执行）。因为考虑的安全性，不断的加锁和解锁，所以效率很低，速度很慢。</p>
<h3 id="如何选择使用哪个list实现类">如何选择使用哪个List实现类？</h3>
<ol>
<li>
<p>看是否在多线程环境下访问。</p>
<p>是：Vector</p>
<p>否：转到2</p>
</li>
<li>
<p>看增删多还是查询多？</p>
<p>增删多：LinkedList</p>
<p>查询多：ArrayList</p>
<p>不知道：ArrayList</p>
</li>
</ol>
<p>List<Type> list = new   xxxx<Type>();</p>
<h3 id="setinterface">Set(interface)</h3>
<p>set是一个接口，<strong>用于描述一个元素不重复的容器</strong>。set里面的重复元素只会出现一次。</p>
<p>首先set是一个容器，既然是容器，那么容器所应该具有的功能它都有。也就说Collection接口中定义的方法，Set里都要有。</p>
<p>通过查阅API，发现Set没有自己独有的方法，Set里所有的方法来自于Collection。</p>
<h3 id="set的实现类">Set的实现类</h3>
<h4 id="hashset-普通set">HashSet （普通set）</h4>
<p>HashSet的特点：</p>
<ol>
<li>不重复</li>
<li>无序</li>
</ol>
<blockquote>
<p>注意：如果要往HashSet中添加自定义类型的数据，你需要给自定义的类添加equals方法，HashSet在添加元素的时候，会拿现有元素逐一和要添加的元素比较（用equals比较），如果相等了，就不添加，比较一遍之后没有相等的，把元素加进来。</p>
</blockquote>
<h4 id="hashset的创建">HashSet的创建</h4>
<ol>
<li>
<p>HashSet() //创建一个空的Set，初始容量为16</p>
</li>
<li>
<p>HashSet(int capacity) //创建一个空的Set，初始容量为指定的容量。</p>
</li>
<li>
<p>HashSet(Collection c) //创建一set，初始内容是c中的元素（会去重）。</p>
</li>
</ol>
<p>HashSet的添加和删除元素API见Set</p>
<blockquote>
<p>HashSet没有获取元素的方法，也没有设置元素的方法。</p>
<p>如何取元素呢？---通过遍历来读取。</p>
</blockquote>
<p>思考？</p>
<p>能否使用for循环遍历Set？-----不能！因为没有下标</p>
<h4 id="hashset的遍历">HashSet的遍历</h4>
<p>假定有如下Set：</p>
<pre><code class="language-java">Set&lt;String&gt; s = new HashSet&lt;&gt;();
s.add(&quot;zhangsan&quot;);
s.add(&quot;lisi&quot;);
s.add(&quot;wangwu&quot;);
s.add(&quot;zhaoliu&quot;);
</code></pre>
<ol>
<li>
<p>使用for..each遍历</p>
<pre><code class="language-java">for(String str : s){
    System.out.println(str);//str就是我们set中每个元素
}
</code></pre>
</li>
<li>
<p>使用Iterator遍历</p>
<pre><code class="language-java">Iterator&lt;String&gt; it = s.iterator();
while(it.hasNext()){
  String str = it.next();
  System.out.println(str);
}
</code></pre>
</li>
</ol>
<h4 id="set另外一个实现类-linkedhashset">Set另外一个实现类 LinkedHashSet</h4>
<p>LinkedHashSet是一个有序的不重复的容器。</p>
<p>特点如下：</p>
<ol>
<li>有序（存放顺序有序）</li>
<li>不重复</li>
</ol>
<h3 id="小节">小节</h3>
<p>Collection是什么？</p>
<p>答：它是一个接口。用来描述容器应该具有哪些功能。（add,addAll,clear,remove,contains,size,iterator）</p>
<p>List是什么？</p>
<p>答：它是一个接口,这个接口继承了Colletion。用来描述一个有序的容器。有序指的是存放顺序。提供了下标的概念（index），围绕下标提供了一堆方法。（add(index,object),addAll(index,collection), remove(index),indexOf(object), lastIndexOf(object), get(index),set(index,object)）</p>
<p>List的实现类有哪些？</p>
<p>ArrayList：底层是数组（内存空间连续），查询快，增删慢。</p>
<p>LinkedList：底层是链表，增删快，查询慢。</p>
<p>Vector：线程安全。</p>
<p><strong>List的遍历方法：</strong></p>
<p>for循环</p>
<p>for each</p>
<p><strong>迭代器</strong></p>
<p>Set是什么？</p>
<p>答：set是一个接口，继承于Collection。用来描述不重复的容器。</p>
<p>Set的实现类有哪些？</p>
<p>HashSet：无序不重复。要求容器里的元素实现了equals方法。</p>
<p>LinkedHashSet：有序不重复。有序指的是存放顺序。也需要元素实现equals放法。</p>
<p>TreeSet：有序不重复。有序指的是内容有序。</p>
<h3 id="treeset-是一个set的实现类">TreeSet 是一个Set的实现类</h3>
<p>TreeSet是一个不重复的容器，而且内容有序。靠Comparable或者Comparator来实现比较，确定是否重复以及谁大谁小。</p>
<p>TreeSet有2大类创建方式：</p>
<ol>
<li>自然排序。 元素本身带有比较方法（本质是元素实现了Comparable接口）</li>
<li>比较器排序。元素本身不具备比较的能力，比较帮元素比较大小。</li>
</ol>
<p>TreeSet底层靠的二叉树来实现内容有序。小的元素放在树的左分支上，大的放在右分支上。读取元素时，TreeSet使用中序遍历的方式读取元素。</p>
<p>TreeSet添加元素以及删除元素和HashSet一样。</p>
<h3 id="小节-2">小节</h3>
<p>Collection描述一个容器</p>
<p>​	List：有序容器，可重复</p>
<p>​		ArrayList： 数组</p>
<p>​		LinkedList： 链表</p>
<p>​		Vector：数组</p>
<p>​	Set：不可重复，通常是无序的。</p>
<p>​		HashSet：普通集合</p>
<p>​		LinkedHashSet：存放顺序有序，不可重复</p>
<p>​		TreeSet：内容有序，不可重读</p>
<h2 id="map接口">Map（接口）</h2>
<p>Map是用来描述一个容器，用来描述一个键值对容器。</p>
<p>Map的特点：键不允许重复。</p>
<p>Map和Colletion是平级的。Map数据键值对接口中的根接口。</p>
<ol>
<li>
<p>添加元素到Map中</p>
<p><strong>put(key, value)</strong> //往Map中存放元素，如果Map中已经有这个key了，会覆盖。如果Map中没有这个key，会把这个键值对存入map</p>
<p>putAll(Map map) //把另外一个map中的元素全部添加到当前map中，如果有key已经存在了，会产生覆盖。</p>
</li>
<li>
<p>移除元素</p>
<p><strong>remove(key)</strong> //根据key移除对应的键值对。</p>
</li>
<li>
<p>修改元素</p>
<p>put(key, value) //如果Map中已经有这个key了，会覆盖. 如果没有就是添加</p>
</li>
<li>
<p>查看Map</p>
<p><strong>size()</strong> //查看里面有多少键值对</p>
<p>containsKey(key) //查看是否有某个key</p>
<p>containsValue(value) //查看是否有某个value</p>
<p><strong>get(key)</strong> //获取key对应的值。</p>
<p><strong>keySet()</strong> //获取所有的key</p>
<p>values() //获取所有的value</p>
<p><strong>entrySet</strong> //获取键值对集合</p>
</li>
</ol>
<h2 id="map的实现类">Map的实现类</h2>
<h3 id="hashmap">HashMap</h3>
<p>HashMap是一个普通的Map。</p>
<h4 id="创建hashmap">创建HashMap</h4>
<ol>
<li>HashMap()  创建一个空的Map，初始容量是16， 加载因子是0.75</li>
<li>HashMap(int capacity) 创建一个空的Map， 初始容量为指定的容量，加载因子是0.75</li>
<li>HashMap(int capacity, float loadFactor) 创建一个空的Map，初始容量和加载因子由参数指定。</li>
<li>HashMap(Map map) 创建一个包含指定键值对的Map。</li>
</ol>
<h3 id="hashmap的使用">HashMap的使用</h3>
<p>增删改查 见Map的API</p>
<h3 id="map的遍历">Map的遍历</h3>
<p>假定有如下Map：</p>
<pre><code class="language-java">Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
map.put(&quot;one&quot;, 100);
map.put(&quot;two&quot;, 88);
map.put(&quot;three&quot;, 96);
map.put(&quot;four&quot;, 88);
</code></pre>
<p>for each遍历</p>
<pre><code class="language-java">Set&lt;String&gt; keys = map.keySet();
for(String key : keys) {
	System.out.println(key+ &quot;----&quot; + map.get(key));
}
</code></pre>
<p>使用迭代器遍历</p>
<pre><code class="language-java">Iterator&lt;String&gt; it = keys.iterator();
while(it.hasNext()) {
	String key = it.next();
	int value = map.get(key);
	System.out.println(key + &quot;===&quot; + value);
}
</code></pre>
<p>for each遍历键值对</p>
<pre><code class="language-java">Set&lt;Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();
for(Entry&lt;String, Integer&gt; e : entries) {
	System.out.println(e.getKey()+ &quot;__&quot;+ e.getValue());
}
</code></pre>
<blockquote>
<p>Entry是专门服务于Map的类。它代表键值对对象，内部含有键和值。如果要取出键和值，使用getKey()以及getValue().</p>
<p>Entry本质上Map中内部类。</p>
</blockquote>
<p>迭代器遍历键值对</p>
<pre><code class="language-java">Iterator&lt;Entry&lt;String,Integer&gt;&gt; it2 = entries.iterator();
while(it2.hasNext()) {
	Entry&lt;String, Integer&gt; e = it2.next();
	System.out.println(e.getKey()+&quot;  &quot;+e.getValue());
}
</code></pre>
<h4 id="linkedhashmap">LinkedHashMap</h4>
<p>存放顺序有序的Map。特点：存放顺序有序，键不能重复。</p>
<h4 id="treemap">TreeMap</h4>
<p>key的内容有序的Map。特点：key的内容有序，键不能重复。</p>
<h4 id="hashtable">HashTable</h4>
<p>它与HashMap非常类似，只不过HashTable是线程安全的。</p>
]]></content>
    </entry>
</feed>