<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zjt-zjt.github.io</id>
    <title>Gridea</title>
    <updated>2019-12-11T11:04:25.328Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zjt-zjt.github.io"/>
    <link rel="self" href="https://zjt-zjt.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://zjt-zjt.github.io/images/avatar.png</logo>
    <icon>https://zjt-zjt.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://zjt-zjt.github.io/post/hello-gridea</id>
        <link href="https://zjt-zjt.github.io/post/hello-gridea">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringMVC]]></title>
        <id>https://zjt-zjt.github.io/post/springmvc-xue-xi-bi-ji</id>
        <link href="https://zjt-zjt.github.io/post/springmvc-xue-xi-bi-ji">
        </link>
        <updated>2018-11-08T13:28:02.000Z</updated>
        <summary type="html"><![CDATA[<!-- SpringMVC 第一天 -->
<h2 id="mvc设计模式">MVC设计模式</h2>
<p>其实在之前JavaWeb阶段我们已经接触到了MVC模式。</p>
<p>MVC里面的M指的的Model（通常包含bean、dao(mapper)、service）；V指的是View，视图层，视图层主要的技术（JSP、HTML、FreeMaker、Themeleaf）；C指的是Controller，控制层。控制层不负责具体数据、逻辑的处理和运算，它只负责将Model层的结果返回给对应的视图层去展示。</p>
]]></summary>
        <content type="html"><![CDATA[<!-- SpringMVC 第一天 -->
<h2 id="mvc设计模式">MVC设计模式</h2>
<p>其实在之前JavaWeb阶段我们已经接触到了MVC模式。</p>
<p>MVC里面的M指的的Model（通常包含bean、dao(mapper)、service）；V指的是View，视图层，视图层主要的技术（JSP、HTML、FreeMaker、Themeleaf）；C指的是Controller，控制层。控制层不负责具体数据、逻辑的处理和运算，它只负责将Model层的结果返回给对应的视图层去展示。</p>
<!-- more -->
<p>在JavaWeb阶段， Controller层指的就是Servlet； View层指的就是JSP或者HTML;  Model层指的就是bean、dao、service。</p>
<p>在J2EE阶段，Controller层指的就是SpringMVC、Structs1\2；  View层不变还是主流的页面展示技术; Model层包括bean、mybatis、service。</p>
<h2 id="springmvc的优势">SpringMVC的优势</h2>
<ul>
<li>SpringMVC是一款很轻量级的框架，要使用它的组件我们往往只需要定义一些最简单的Java类，然后添加某些注解就可以了</li>
<li>SpringMVC的参数注入只直接注入到方法中，可以很好的做到不同请求间数据的隔离，而Struts2是注入到类实例变量上，不同的请求可能会覆盖参数。</li>
<li>SpringMVC可以很轻易的和Spring整合，而Struts需要做比较复杂的配置。</li>
</ul>
<h2 id="springmvc简单使用">SpringMVC简单使用</h2>
<ol>
<li>
<p>添加依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>在web.xml中配置DispatcherServlet</p>
<pre><code class="language-xml">&lt;servlet&gt;
    &lt;servlet-name&gt;aa&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;!-- 指定SpringMVC 配置文件位置，DispatcherServlet初始化时会初始化Spring上下文（WebApplicationContext） --&gt;
    &lt;!-- 默认配置文件寻找位置：/WEB-INF/{servlet-name}-servlet.xml，如果名字符合默认寻找规则，可以不指定配置文件路径 --&gt;
    &lt;!--&lt;init-param&gt;
      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
      &lt;param-value&gt;/WEB-INF/aa-servlet.xml&lt;/param-value&gt;
    &lt;/init-param&gt;--&gt;
    &lt;!-- 配置容器启动时初始化DispatcherServlet --&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;aa&lt;/servlet-name&gt;
    &lt;!-- 映射路径配置成/，代表当前Servlet是一个默认Servlet，就是当其他Servlet都无法处理请求时，由默认Servlet出马 --&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;!--    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;--&gt;
  &lt;/servlet-mapping&gt;
</code></pre>
</li>
<li>
<p>配置SpringMVC  dispatcher-servlet.xml</p>
<p>SpringMVC大部分组件都有默认配置，我们一般简单应用只需要指定视图解析器就行了</p>
<p>dispatcher-servlet.xml</p>
<pre><code class="language-xml">&lt;!-- 配置视图解析器，用于将Handler方法中返回的视图名解析成真正可展示的页面 --&gt;
&lt;mvc:view-resolvers&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/&quot; /&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;
&lt;/mvc:view-resolvers&gt;
</code></pre>
</li>
<li>
<p>定义Controller</p>
<p>新建一个普通类，然后添加<code>@Controller</code>注解，就可以了</p>
</li>
<li>
<p>定义请求处理方法(Handler)</p>
<p>在Controller类中定义一个普通的方法，添加<code>@RequestMapping</code>注解就可以了</p>
</li>
</ol>
<h2 id="springmvc主要组件">SpringMVC主要组件</h2>
<h3 id="rootapplicationcontext和servletapplicationcontext">RootApplicationContext和ServletApplicationContext</h3>
<figure data-type="image" tabindex="1"><img src="https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/images/mvc-context-hierarchy.png" alt="父子上下文概念"></figure>
<h4 id="两个applicationcontext的联系和区别">两个ApplicationContext的联系和区别</h4>
<h3 id="视图解析器">视图解析器</h3>
<p>视图解析器的作用是将请求处理方法中的返回值解析成一个真正可以渲染的页面。</p>
<h4 id="常用的视图解析器">常用的视图解析器</h4>
<ul>
<li>
<p>InternalResourceViewResolver</p>
<p>内部资源解析器： 用于将返回值对应到项目路径下的某个可显示的页面。比如方法返回值是index字符串，那么<code>InternalResourceViewResolver</code>解析器会在index前加上指定的前缀，在index后加上指定的后缀来拼接成指向某个视图的路径。</p>
<pre><code class="language-xml">&lt;!-- 配置视图解析器，用于将Handler方法中返回的视图名解析成真正可展示的页面 --&gt;
&lt;mvc:view-resolvers&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/&quot; /&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;
&lt;/mvc:view-resolvers&gt;
</code></pre>
</li>
</ul>
<h3 id="参数传递">参数传递</h3>
<h4 id="页面参数传递到controller">页面参数传递到Controller</h4>
<h5 id="requestparam">@RequestParam</h5>
<p>获取请求参数，包括通过GET请求中的查询参数、POST请求中的参数等</p>
<pre><code class="language-java">@RequestMapping(&quot;/hello&quot;)
public String toHelloPage(@RequestParam String message, Model model) {
	model.addAttribute(&quot;msg&quot;, message);
	return &quot;hello_springmvc&quot;;
}


// 当方法参数名和请求参数不一样时，可以使用注解的参数对应起来
@RequestMapping(&quot;/hello&quot;)
public String toHelloPage(@RequestParam(&quot;message&quot;) String msg, Model model) {
	model.addAttribute(&quot;msg&quot;, message);
	return &quot;hello_springmvc&quot;;
}
</code></pre>
<blockquote>
<p>访问: http://localhost:8080/hello?message=zhangsan 时，message参数会自动注入到方法的message参数中。</p>
</blockquote>
<h5 id="requestheader">@RequestHeader</h5>
<p>获取请求头中的参数，如浏览器默认自带的userAgent就是请求头参数</p>
<pre><code class="language-java">@RequestMapping(&quot;/hello&quot;)
public String toHelloPage(@RequestHeader String userAgent, Model model) {
	model.addAttribute(&quot;msg&quot;, userAgent);
	return &quot;hello_springmvc&quot;;
}


// 当方法参数名和请求头参数不一样时，可以使用注解的参数对应起来
@RequestMapping(&quot;/hello&quot;)
public String toHelloPage(@RequestHeader(&quot;userAgent&quot;) String ua, Model model) {
	model.addAttribute(&quot;msg&quot;, ua);
	return &quot;hello_springmvc&quot;;
}
</code></pre>
<blockquote>
<p>会自动将请求头中的userAgent参数注入到方法中</p>
</blockquote>
<h5 id="pathvariable">@PathVariable</h5>
<p>获取请求地址中的参数，注入到方法参数中</p>
<pre><code class="language-java">@RequestMapping(&quot;/hello/{sname}&quot;)
public String toHelloPage(@PathVariable String sname, Model model) {
	model.addAttribute(&quot;msg&quot;, sname);
	return &quot;hello_springmvc&quot;;
}


// 当方法参数名和请求地址中参数不一样时，可以使用注解的参数对应起来
@RequestMapping(&quot;/hello/{sname}&quot;)
public String toHelloPage(@PathVariable(&quot;sname&quot;) String sn, Model model) {
	model.addAttribute(&quot;msg&quot;, sn);
	return &quot;hello_springmvc&quot;;
}
</code></pre>
<blockquote>
<p>访问：http://localhost:8080/hello/zhangsan  会自动将zhangsan注入到方法的参数中</p>
</blockquote>
<h5 id="requestattribute">@RequestAttribute</h5>
<p>jsp中</p>
<pre><code class="language-jsp">&lt;%
        request.setAttribute(&quot;sname&quot;, &quot;虞姬req&quot;);
        request.getRequestDispatcher(&quot;/param/req_scope&quot;).forward(request, response);
%&gt;
</code></pre>
<p>Controller中</p>
<pre><code class="language-java">/**
  * 请求作用域中的参数的传递
  * @return
  */
@RequestMapping(&quot;/req_scope&quot;)
public String requestScopeParamShow(@RequestAttribute String sname, Model model) {
    model.addAttribute(&quot;sname&quot;, sname);
    model.addAttribute(&quot;type&quot;, &quot;请求作用域参数&quot;);
    return &quot;param_show&quot;;
}

</code></pre>
<blockquote>
<p>获取请求作用域中的参数</p>
</blockquote>
<h5 id="sessionattribute">@SessionAttribute</h5>
<blockquote>
<p>获取Session作用域中的参数，用法和上面请求作用域中使用类似</p>
</blockquote>
<h5 id="cookievalue">@CookieValue</h5>
<p>jsp中代码</p>
<pre><code class="language-jsp">cookie参数传递：&lt;br /&gt;
&lt;%
response.addCookie(new Cookie(&quot;sname&quot;, &quot;yuji_cookie&quot;));
%&gt;
&lt;a href=&quot;/param/cookie&quot;&gt;发起请求&lt;/a&gt;

</code></pre>
<p>Controller中</p>
<pre><code class="language-java">/**
  * Cookie中的参数的传递
  * @return
  */
@RequestMapping(&quot;/cookie&quot;)
public String cookieParamShow(@CookieValue String sname, Model model) {
    model.addAttribute(&quot;sname&quot;, sname);
    model.addAttribute(&quot;type&quot;, &quot;cookie参数&quot;);
    return &quot;param_show&quot;;
}

</code></pre>
<blockquote>
<p>获取Cookie中的指定数据</p>
</blockquote>
<blockquote>
<p>上面这几个注解都是用于在方法的参数上标注，用于获取不同种类的参数</p>
</blockquote>
<h4 id="controller中的数据传递到页面">Controller中的数据传递到页面</h4>
<h5 id="model">Model</h5>
<p>handler方法定义：</p>
<pre><code class="language-java">@RequestMapping(&quot;/show_msg&quot;)
public String showMessage(Model model) {
    model.addAttribute(&quot;msg&quot;, &quot;我是通过model传过来的参数&quot;);
    return &quot;message_page&quot;;
}

</code></pre>
<p>message_page.jsp</p>
<pre><code class="language-jsp">&lt;h1&gt;
    获取后台参数： ${msg}
&lt;/h1&gt;

</code></pre>
<h5 id="modelandview">ModelAndView</h5>
<pre><code class="language-java">/**
 * ModelAndView其实是将数据Model和视图View做了一个封装，底层实现原理一样
 */
@RequestMapping(&quot;/show_msg&quot;)
public ModelAndView showMessage(ModelAndView mv) {
    mv.addObject(&quot;msg&quot;, &quot;我是通过model传过来的参数&quot;);
    mv.setViewName(&quot;message_page&quot;);
    return mv;
}

</code></pre>
<blockquote>
<p>Model和ModelAndView传递的参数本质上也是用请求作用域来实现的，所以仅对请求转发有效。</p>
</blockquote>
<h3 id="视图控制器">视图控制器</h3>
<p>用于通过配置的方式简化我们项目中不含业务逻辑的页面跳转，省去了我们写一个空方法的步骤。</p>
<h4 id="视图控制器的作用和用法">视图控制器的作用和用法</h4>
<p>试想一下，如果我们的工程中有这样的一个需求，比如当用户点了某个链接和按钮的时候，我们需要做一个页面跳转，这个跳转的目标可能是一个公开目录的页面也可能是私有目录（/WEB-INF/下）的页面、还可能是跳转到后台Controller的某个方法中，我们如何实现？</p>
<p>示例：比如我们想将登陆页设置为一个项目默认欢迎页面</p>
<p>方案一：在Controller中添加一个拦截/的handler方法</p>
<pre><code class="language-java">@RequestMapping(&quot;/&quot;)
public String toWelcomePage() {
    return &quot;login&quot;;
}

</code></pre>
<p>方法二：使用视图控制器</p>
<p>在dispatcher-servlet.xml（SpringMVC配置文件）配置中添加</p>
<pre><code class="language-xml">&lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;login&quot; /&gt;

</code></pre>
<ul>
<li>path: 指定要匹配的访问路径</li>
<li>view-name: 返回的逻辑视图名</li>
<li>status-code: 设置响应状态码。(注：不能通过只设置状态码，不设置view-name实现只返回code，没有页面的处理)</li>
</ul>
<blockquote>
<p>view-name不仅可以是逻辑视图名，还可以添加forward、redirect前缀，通过转发或重定向的方式跳转到一个具体的路径，如：&lt;mvc:view-controller path=&quot;/&quot; view-anme=&quot;forward:/WEB-INF/login.jsp&quot; /&gt;</p>
</blockquote>
<!-- SpringMVC 第二天 -->
<h3 id="设置web项目的默认欢迎页">设置Web项目的默认欢迎页</h3>
<ul>
<li>
<p>在web.xml中使用<welcome-file-list>标签指定</p>
</li>
<li>
<p>使用上面提到的视图控制器</p>
<pre><code class="language-xml">&lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;逻辑视图名&quot; /&gt;
&lt;!-- 当工程中存在Tomcat默认欢迎页同名文件时此种方式可能失效，比如index.html、index.jsp、index.htm --&gt;

</code></pre>
</li>
</ul>
<h3 id="静态资源处理">静态资源处理</h3>
<pre><code class="language-xml">&lt;!-- 针对静态资源的处理 --&gt;
    &lt;!-- http://localhost:8080/static/css/index.css --&gt;
&lt;mvc:resources mapping=&quot;/static/**&quot; location=&quot;/static/&quot; /&gt;

</code></pre>
<h3 id="重定向和转发">重定向和转发</h3>
<h4 id="在servlet实现重定向和转发">在Servlet实现重定向和转发：</h4>
<p>重定向：response.sendRedirect(&quot;xxx.jsp&quot;);</p>
<p>转发： request.getRequestDispatcher(&quot;xxx.jsp&quot;).forward(request, response);</p>
<h4 id="在springmvc中">在SpringMVC中</h4>
<h5 id="请求转发有三种方式">请求转发有三种方式</h5>
<ul>
<li>在Handler方法中直接返回逻辑视图名称</li>
<li>在Handler方法中返回&quot;forward:路径&quot;</li>
<li>在Handler方法中返回InternalResourceView对象</li>
</ul>
<blockquote>
<p>其中第二种和第三种作用一样， 都是将路径用请求转发的方式跳转，返回的路径时不经过视图解析器处理的；而第一种虽然也是通过请求转发方式跳转，但是返回值会作为逻辑视图名称，经过视图解析器处理后，才渲染。</p>
</blockquote>
<h5 id="重定向有两种方式">重定向有两种方式</h5>
<ul>
<li>在Handler方法中返回&quot;redirect:路径&quot;</li>
<li>在Handler方法中返回RedirectView对象</li>
</ul>
<blockquote>
<p>这两种方法效果一样。 注意使用重定向的方式跳转页面，Model中的数据就无法带到页面了（因为Model底层也是用请求作用域来传递参数的）。</p>
</blockquote>
<h3 id="restfull服务接口开发">RESTFull服务接口开发</h3>
<p>SpringMVC给我们提供了一系列的注解用于支持RESTFull风格的服务开发</p>
<h4 id="常用restfull注解">常用RESTFull注解</h4>
<ul>
<li>
<p><code>@RestController</code></p>
<p>该注解本身是一个组合注解，由<code>@Controller</code>和<code>@ResponseBody</code>两个注解组成，所以拥有这两个注解的作用。 在类上声明后，该类会变成一个Controller类，同时，方法的返回值会作为响应体经过消息转换器直接响应给客户端，而不会将其作为视图渲染。</p>
<pre><code class="language-java">@RestController // 这个注解其实是组合了下面两个注解的作用
//@Controller
//@ResponseBody
public class UserRestController {

}

</code></pre>
</li>
<li>
<p><code>@GetMapping</code> :</p>
<p>作用： 申明当前handler方法只匹配GET请求</p>
<p>使用示例</p>
<pre><code class="language-java">@GetMapping(&quot;/{id}&quot;)
public User getUserById(@PathVariable Integer id) {
    return userService.findById(id);
}

</code></pre>
</li>
<li>
<p><code>@PostMapping</code>: 申明当前handler方法只匹配POST请求</p>
</li>
<li>
<p><code>@DeleteMapping</code>: 申明当前handler方法只匹配DELETE请求</p>
</li>
<li>
<p><code>@PutMapping</code>: 申明当前handler方法只匹配PUT请求</p>
</li>
</ul>
<blockquote>
<p>上面四个注解分别对应HTTP的一种请求方法，使用方法类似。</p>
</blockquote>
<p>上面四个注解其实是一种快捷注解， 等效于使用下面代码：</p>
<pre><code class="language-java">@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.GET)
@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.POST)
@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.PUT)
@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.DELETE)

</code></pre>
<ul>
<li>@PathVariable: 获取请求地址中的变量，注入到方法参数中</li>
</ul>
<h4 id="返回json格式的数据-消息转换器">返回JSON格式的数据 —— 消息转换器</h4>
<h5 id="消息转换器是什么">消息转换器是什么</h5>
<p>之前我们在写普通Controller时，handler方法的返回值要是就是一个String（逻辑视图名），要么就是一个ModelAndView、View对象。</p>
<p>而我们使用了RestController之后，方法的返回值已经不会被作为视图去渲染了，这时候我们的方法其实可以返回任意类型的数据。这些数据会直接通过响应体以流的方式返回给客户端。</p>
<p>我们知道Java中的对象是不能直接用流的方式读取的，需要序列化。比如我们的handler方法返回了一个User类型，SpringMVC就不知道如果将这个类型返回给客户端了。这时就需要我们通过配置消息转换器来完成这种类型对象的返回处理。 而在RESTFull服务中，对象绝大部分传递方式就是通过JSON格式。</p>
<h5 id="如何配置一个转换json格式的消息转换器">如何配置一个转换JSON格式的消息转换器</h5>
<ul>
<li>
<p>使用SpringMVC默认的Jackson库</p>
<ol>
<li>
<p>引入依赖</p>
<pre><code class="language-xml">&lt;!-- jackson依赖，用于将handler方法返回的对象直接转换成JSON数据 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;version&gt;2.9.7&lt;/version&gt;
&lt;/dependency&gt;

</code></pre>
</li>
<li>
<p>开启mvc注解支持</p>
<pre><code class="language-xml">&lt;mvc:annotation-driven /&gt;

</code></pre>
</li>
<li>
<p>定义Controller类</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/user&quot;)
public class UserRestController {
    
    @GetMapping(&quot;/{id}&quot;)
    public User getUserById(Integer id) {
        return userService.findById(id);
    }
    
}

</code></pre>
</li>
</ol>
<blockquote>
<p>Jackson是SpringMVC默认的JSON格式消息转换器， 所以在不配置额外转json参数时，我们可以直接只引入jackson依赖，再开启mvc直接支持就可以了。而第三方的转换库如FastJSON就必须显示配置MessageConverter</p>
</blockquote>
</li>
<li>
<p>使用阿里巴巴的FastJSON库</p>
<ol>
<li>
<p>引入依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
     &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
     &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
     &lt;version&gt;1.2.57&lt;/version&gt;
&lt;/dependency&gt;

</code></pre>
</li>
<li>
<p>配置MessageConverter</p>
<pre><code class="language-xml">&lt;mvc:annotation-driven&gt;
    &lt;mvc:message-converters&gt;
        &lt;bean class=&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;&gt;
            &lt;property name=&quot;defaultCharset&quot; value=&quot;UTF-8&quot; /&gt;
            &lt;property name=&quot;fastJsonConfig&quot;&gt;
                &lt;!-- 设置转换JSON的参数 --&gt;
                &lt;bean class=&quot;com.alibaba.fastjson.support.config.FastJsonConfig&quot;&gt;
                    &lt;property name=&quot;dateFormat&quot; value=&quot;yyyy-MM-dd HH:mm:ss&quot; /&gt;
                &lt;/bean&gt;
            &lt;/property&gt;
            &lt;property name=&quot;supportedMediaTypes&quot;&gt;
            &lt;!-- 指定转换完JSON后返回的响应头和编码，添加text/html是为了处理在IE下application/json会弹出下载框问题 --&gt;
                &lt;list&gt;
                    &lt;!--&lt;value&gt;text/html;charset=UTF-8&lt;/value&gt;--&gt;                
                    &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt;
                &lt;/list&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/mvc:message-converters&gt;
&lt;/mvc:annotation-driven&gt;

</code></pre>
</li>
<li>
<p>定义Controller类</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/user&quot;)
public class UserRestController {
    
    @GetMapping(&quot;/{id}&quot;)
    public User getUserById(Integer id) {
        return userService.findById(id);
    }
    
}

</code></pre>
</li>
</ol>
</li>
</ul>
<h4 id="通过网页模拟restfull请求">通过网页模拟RESTFull请求</h4>
<p>通过SpringMVC给我们提供的一个过滤器，我们可以用表单模拟各种RESTFull的请求，使用方法如下：</p>
<ol>
<li>
<p>在web.xml中添加过滤器</p>
<pre><code class="language-xml">&lt;filter&gt;
    &lt;filter-name&gt;httpMethodFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;httpMethodFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;

</code></pre>
</li>
<li>
<p>在表单中添加name为_method的hidden域，并将表单的method设置为post</p>
<pre><code class="language-html">&lt;!-- 使用表单模拟发起一个DELETE请求，删除user表中id为57的数据 --&gt;
&lt;form action=&quot;/user/57&quot; method=&quot;post&quot;&gt;
    &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;delete&quot; /&gt;
    &lt;input type=&quot;number&quot; name=&quot;id&quot; /&gt;
    &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;
    &lt;input type=&quot;submit&quot; /&gt;
&lt;/form&gt;

</code></pre>
</li>
</ol>
<blockquote>
<p>由于RESTFull请求通常发生在服务于服务之间的调用，所以有些请求用浏览器不太好模拟，建议使用专业的网络测试工具postman来进行测试。</p>
</blockquote>
<h4 id="resttemplate工具类">RestTemplate工具类</h4>
<p>SpringMVC帮我们封装的一个Rest请求工具，可以使用一个URI地址发起网络请求，并且将结果封装成一个指定的对象。</p>
<h3 id="处理请求乱码">处理请求乱码</h3>
<p>SpringMVC给我们提供了一个专门用来解决post请求乱码的过滤器，我们只需将其配置到web.xml中，就可以避免post请求乱码，免去了我们自己写过滤器的麻烦</p>
<p>在web.xml中</p>
<pre><code class="language-xml">&lt;!-- 解决POST请求乱码 --&gt;
&lt;filter&gt;
    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;forceEncoding&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;

</code></pre>
<blockquote>
<p>注意： 如果项目中配置了多个过滤器，建议将此过滤器放到所有过滤器的最上面。</p>
</blockquote>
<h3 id="在springmvc方法中支持的参数">在SpringMVC方法中支持的参数</h3>
<p>SpringMVC的handler方法中支持诸如很多特殊类型的参数，常用的有</p>
<h5 id="注入原生servlet对象">注入原生Servlet对象</h5>
<ul>
<li>javax.servlet.ServletRequest</li>
<li>javax.servlet.ServletResponse</li>
<li>javax.serlvet.http.HttpSession</li>
</ul>
<h5 id="以流的方式读取请求体-以流的方式响应到客户端">以流的方式读取请求体、以流的方式响应到客户端</h5>
<ul>
<li><s>java.io.InputStream、java.io.Reader</s></li>
<li><s>java.io.OutputStream、java.io.Writer</s></li>
</ul>
<h5 id="读取请求体和请求头数据">读取请求体和请求头数据</h5>
<ul>
<li>HttpEntity</li>
</ul>
<h5 id="向页面传参">向页面传参</h5>
<ul>
<li>java.util.Map，org.springframework.ui.Model、org.springframework.ui.ModelMap</li>
</ul>
<!-- SpringMVC 第三天 -->
<h3 id="文件上传">文件上传</h3>
<h4 id="说明">说明</h4>
<p>在Java中，主流的文件上传方式有两种，分别是通用文件上传(commons-fileupload)和Servlet3.0方式的文件上传。SpringMVC分别对着两种方式都做了支持。</p>
<ul>
<li>CommonsMultipartResolver</li>
<li>StandardServletMultipartResolver</li>
</ul>
<blockquote>
<p>除此之外SpringMVC对文件上传的接口做了统一的封装，使用<code>MultipartFile</code>接口代替了通用上传中的<code>FileItem</code>和Servlet3.0中的<code>Part</code>，使得开发人员在业务代码中可以使用统一的接口处理，而不用管底层用的是哪种文件上传实现方式。</p>
</blockquote>
<h4 id="基于apache-fileupload通用文件上传包">基于Apache Fileupload通用文件上传包</h4>
<ol>
<li>
<p>添加依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
    &lt;version&gt;1.4&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-io&lt;/groupId&gt;
    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
    &lt;version&gt;2.6&lt;/version&gt;
&lt;/dependency&gt;

</code></pre>
</li>
<li>
<p>在SpringMVC配置文件中添加MultipartResolver文件上传解析器</p>
<pre><code class="language-xml">&lt;!-- 配置基于apache fileupload的通用文件上传器（注意：id属性不可省略） --&gt;
&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
    &lt;!-- 指定文件上传编码 --&gt;
    &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot; /&gt;
&lt;/bean&gt;

</code></pre>
</li>
<li>
<p>在Controller中编写文件上传逻辑代码</p>
<pre><code class="language-java">@RequestMapping(&quot;/upload&quot;)
public String upload(@RequestParam(&quot;myFile&quot;) MultipartFile file, HttpServletRequest req, Model model) {
    try {
        // 使用SpringMVC给我们提供的工具类获取项目中upload文件夹在硬盘上的绝对路径
        String uploadPath = WebUtils.getRealPath(req.getServletContext(), &quot;/upload/&quot;);
        // 将上传的文件写到上传目录
        file.transferTo(new File(uploadPath+file.getOriginalFilename()));
    } catch (IOException e) {
        e.printStackTrace();
    }
}

</code></pre>
</li>
</ol>
<h4 id="基于servlet30标准api文件上传">基于Servlet3.0标准API文件上传</h4>
<ol>
<li>
<p>开启Servlet文件上传支持</p>
<p>web.xml</p>
<pre><code class="language-xml">&lt;servlet&gt;
    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;!-- 开启Servlet文件上传支持 --&gt;
    &lt;multipart-config /&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

</code></pre>
</li>
<li>
<p>在SpringMVC中配置MultipartResolver</p>
<pre><code class="language-xml">&lt;!-- 配置基于Servlet3.0文件上传器（注意：id属性不可省略） --&gt;
&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.support.StandardServletMultipartResolver&quot; /&gt;

</code></pre>
</li>
<li>
<p>在Controller中编写文件上传逻辑代码</p>
<blockquote>
<p>实现方式同通用上传代码一样。</p>
</blockquote>
</li>
</ol>
<h4 id="文件名上传乱码问题">文件名上传乱码问题</h4>
<ul>
<li>
<p>使用通用上传方式的解决方法</p>
<p>在配置的CommonsMultipartResolver bean中注入属性</p>
<pre><code class="language-xml">&lt;!-- 配置基于apache fileupload的通用文件上传器（注意：id属性不可省略） --&gt;
&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
    &lt;!-- 指定文件上传编码 --&gt;
    &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot; /&gt;
&lt;/bean&gt;

</code></pre>
</li>
<li>
<p>使用Servlet3.0标准上传方式的解决方法</p>
<p>通过配置SpringMVC提供的编码过滤器解决</p>
<p>web.xml</p>
<pre><code class="language-xml">&lt;filter&gt;
    &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;forceEncoding&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;

</code></pre>
<blockquote>
<p>本质上还是设置请求的编码 request.setCharacterEncoding(&quot;UTF-8&quot;);</p>
</blockquote>
</li>
</ul>
<h3 id="拦截器">拦截器</h3>
<h4 id="拦截器-vs-过滤器">拦截器 VS 过滤器</h4>
<p>过滤器是Servlet规范中提供的一项技术。不依赖于任何第三方框架。它的作用主要用来做两件事： 加工请求、过滤请求。</p>
<p>拦截器是SpringMVC自己封装的一项基于Handler拦截的结束。也就是说只有在SpringMVC框架里面才有拦截器的概念。拦截器拦截的对象是Handler。它的全称是 HandlerInterceptor。</p>
<p>加上拦截器以后，请求处理流程：  request -&gt; DispatcherServlet -&gt; HandlerMapping -&gt; HandlerExecutionChain(包含了目标handler和若干个拦截器) -&gt; HandlerAdapter -&gt; 循环调用HandlerExecutionChain对象中所有拦截器的prehandler方法 -&gt; 如果preHandler返回false，那么handler将不会被调用。反之，才会正常调用。</p>
<h4 id="如何使用拦截器">如何使用拦截器</h4>
<h5 id="定义拦截器类">定义拦截器类</h5>
<p>新建一个类实现HandlerInterceptor接口</p>
<pre><code class="language-java">/**
 * 定义拦截器步骤：
 *      1. 定义一个普通类，实现HandlerInterceptor接口
 *      2. 按需实现接口中的方法
 *      3. 在SpringMVC配置文件中通过&lt;mvc:interceptors&gt;&lt;/mvc:interceptors&gt;配置拦截器
 */
public class NotAllowedInterceptor implements HandlerInterceptor {

    /**
     * 此回调方法在执行Handler之前被调用
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println(&quot;进入NotAllowedInterceptor, 凡是我能拦截到的请求，一律不准通过!&quot;);
        return false;
    }

    /**
     * 此回调方法在执行Handler之后被调用
     * @param request
     * @param response
     * @param handler
     * @param modelAndView
     * @throws Exception
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {

    }

    /**
     * 此回调方法在DispatcherServlet最终响应之前被调用
     * @param request
     * @param response
     * @param handler
     * @param ex
     * @throws Exception
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {

    }
}

</code></pre>
<h5 id="配置拦截器">配置拦截器</h5>
<h6 id="全局拦截器">全局拦截器</h6>
<pre><code class="language-xml">&lt;mvc:interceptors&gt;
    &lt;!-- 这种方式配置的拦截器会拦截所有请求 --&gt;
    &lt;bean class=&quot;com.lanou3g.springmvc.interceptor.NotAllowedInterceptor&quot; /&gt;
&lt;/mvc:interceptors&gt;

</code></pre>
<h6 id="拦截指定请求的拦截器">拦截指定请求的拦截器</h6>
<pre><code class="language-xml">&lt;mvc:interceptors&gt;
    &lt;mvc:interceptor&gt;
        &lt;!-- 拦截的请求 --&gt;
        &lt;mvc:mapping path=&quot;/admin/**&quot; /&gt;
        &lt;!-- 不拦截的请求 --&gt;
        &lt;mvc:exclude-mapping path=&quot;/intercepor/**&quot;/&gt;
        &lt;!-- 配置我们定义的实现了HandlerInterceptor接口的类 --&gt;
        &lt;bean class=&quot;com.lanou3g.springmvc.interceptor.NotAllowedInterceptor&quot; /&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;

</code></pre>
<h3 id="ssm整合">SSM整合</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring]]></title>
        <id>https://zjt-zjt.github.io/post/spring</id>
        <link href="https://zjt-zjt.github.io/post/spring">
        </link>
        <updated>2018-09-04T11:00:31.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h2 id="ioc容器概念">IOC容器概念</h2>
<p>IOC其实就是一个对象的容器。全称Inversion Of Control 控制反转，核心的作用就是将原来由开发人员来控制的对象管理操作交由Spring来管理。</p>
<p>SpringIOC不仅帮我们管理了对象的创建，还包括给对象增加了生命周期行为、作用域(单例、非单例)、懒加载。 配合Spring的DI， 更能方便的解决对象属性值注入、对象之间的依赖注入问题。</p>
<h2 id="ioc容器初始化方式">IOC容器初始化方式</h2>
<h3 id="classpathxmlapplicationcontext">ClassPathXmlApplicationContext</h3>
<p>该类负责加载类路径下的xml配置文件的方式，去初始化IOC容器上下文，具体使用步骤如下：</p>
<ol>
<li>
<p>编写配置文件</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    
    &lt;!-- 使用bean标签将对象配置到ioc容器中 --&gt;
    &lt;bean id=&quot;man&quot; class=&quot;com.lanou3g.bean.Man&quot; /&gt;
    &lt;bean id=&quot;apple&quot; class=&quot;com.lanou3g.bean.Food&quot; /&gt;
&lt;/beans&gt;
</code></pre>
</li>
<li>
<p>加载配置文件，初始化IOC容器</p>
</li>
</ol>
<pre><code class="language-java">   // 加载单个xml配置，初始化上下文
   ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext1.xml&quot;);
  
   // 加载多个xml配置，初始化上下文
   ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(new String[]{&quot;applicationContext1.xml&quot;, &quot;applicationContext2.xml&quot;});
  
   // 加载当前运行类所在的类路径下所有以application开头的配置文件
   ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;appliction*.xml&quot;);
  
   // 加载工程中所有类路径下所有以application开头的配置文件
   ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath*:appliction*.xml&quot;);
  
   // 加载工程中所有类路径下所有以application或spring开头的配置文件
   ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(new String[]{&quot;classpath*:appliction*.xml&quot;, &quot;classpath*:spring*.xml&quot;});
</code></pre>
<blockquote>
<p>配置文件路径中可以包含通配符(*)和前缀(classpath*:，代表所有类路径，包括源码类路径和单元测试类路径)</p>
</blockquote>
<ol start="3">
<li>
<p>从容器中获取对象</p>
<pre><code class="language-java">// 通过xml中配置的bean的id或name属性的值获取bean, 返回的类型是Object，需要强转成对象真正的类型
Man man = (Man) cxt.getBean(&quot;man&quot;); 
// 通过bean的名称获取bean的同时，指定类型 
Man man1 = cxt.getBean(&quot;man&quot;,Man.class); 
// 通过类型从容器中获取bean，如果容器中该类型的bean有多于一个，则会报错
Man man2 = cxt.getBean(Man.class); 

// 调用对象的方法
man.eat();
man.play();
</code></pre>
</li>
</ol>
<h3 id="annotationconfigapplicationcontext">AnnotationConfigApplicationContext</h3>
<p>加载通过Java注解方式配置的Bean上下文。具体使用步骤如下：</p>
<ol>
<li>
<p>定义配置类</p>
<pre><code class="language-java">@Configuration	//代表该类是一个bean的配置类，类似于xml配置中的&lt;beans&gt;标签
public class MyConfiguration {

}
</code></pre>
<ol>
<li>
<p>开启注解支持，配置扫描包路径</p>
<p>如果是通过ClassPathXmlApplicationContext初始化的上下文，则在xml中添加如下配置：</p>
<pre><code class="language-xml">&lt;!-- 添加context命名空间 --&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

&lt;!-- 下面两个配置用于xml和注解配置混合使用时，开启注解扫描支持，并指定扫描的包路径 --&gt;
&lt;!-- 如果指定了扫描包路径，该配置可省略 --&gt;
&lt;context:annotation-config /&gt; 
&lt;context:component-scan base-package=&quot;com.lanou3g.spring&quot; /&gt;
</code></pre>
<p>如果是通过AnnotationConfigApplicationContext初始化的上下文，则需要在t通过<code>@Configuration</code>注解标注的配置类上添加 @ComponentScans注解：</p>
<pre><code class="language-java">@Configuration
@ComponentScan(basePackages = &quot;com.lanou.spring&quot;) //指定扫描包路径
public class MyConfiguration {

}
</code></pre>
</li>
<li>
<p>配置Bean</p>
<p>通过注解方式有两种方式可以将类的对象交由IOC容器中管理</p>
<ul>
<li>
<p>通过@Component的方式定义</p>
<pre><code class="language-java">@Component
public class King {
}
</code></pre>
<blockquote>
<p>适用于我们自己定义的类，或者我们可以修改源代码的类</p>
</blockquote>
</li>
<li>
<p>通过@Bean注解定义</p>
<pre><code class="language-java">public class King {
}


@Configuration
public class MyApplicationContextConf {
    @Bean
    public King king() {
        return new King();
    }
}
</code></pre>
<blockquote>
<p>适用于需要将第三方jar包中的类交由ioc管理，因为我们不能修改jar包中的代码，无法给其添加@Component注解</p>
</blockquote>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p>加载配置类，初始化IOC容器</p>
<pre><code class="language-java">// 加载单个注解配置，初始化上下文
AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(MyConfiguration.class);

// 加载多个注解配置，初始化上下文
AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(new Class[]{MyConfiguration1.class, MyConfiguration2.class});
</code></pre>
</li>
<li>
<p>从容器中获取bean</p>
<pre><code class="language-java">// 通过xml中配置的bean的id或name属性的值获取bean, 返回的类型是Object，需要强转成对象真正的类型
Man man = (Man) cxt.getBean(&quot;man&quot;); 
// 通过bean的名称获取bean的同时，指定类型 
Man man1 = cxt.getBean(&quot;man&quot;,Man.class); 
// 通过类型从容器中获取bean，如果容器中该类型的bean有多于一个，则会报错
Man man2 = cxt.getBean(Man.class); 

// 调用对象的方法
man.eat();
man.play();
</code></pre>
</li>
</ol>
<h2 id="bean初始化方式">Bean初始化方式</h2>
<h3 id="构造方法方式最常用">构造方法方式（最常用）</h3>
<pre><code class="language-xml">&lt;bean id=&quot;xx&quot; class=&quot;com.test.StudentDao&quot; /&gt;
</code></pre>
<h3 id="静态工厂方法">静态工厂方法</h3>
<pre><code class="language-xml">&lt;!-- 
	class：指定的是静态工厂类，而不是将要创建的对象类型
	factory-method: 指定的是工厂中的静态方法 
--&gt;
&lt;bean id=&quot;xx&quot; class=&quot;com.test.StudentDaoFactory&quot; factory-method=&quot;createDao&quot; /&gt;
</code></pre>
<h3 id="实例工厂方法">实例工厂方法</h3>
<pre><code class="language-xml">&lt;!-- 
	class：指定的是实例工厂类 
--&gt;
&lt;bean id=&quot;xxFactory&quot; class=&quot;com.test.StudentDaoFactory&quot; /&gt;
&lt;!-- 
	factory-bean：指定的是实例工厂对象
	factory-method: 指定的是工厂中的实例方法 
--&gt;
&lt;bean id=&quot;xx&quot; factory-bean=&quot;xxFactory&quot; factory-method=&quot;createDao&quot; /&gt;
</code></pre>
<h2 id="bean的命名">Bean的命名</h2>
<p>在XML中配置中可以通过<bean>标签上的id、name属性值给一个bean命名，以便在其他地方引用。</p>
<p>id属性： bean的唯一名称，只允许出现一个值。且同一个IOC容器中不允许出现两个id值一样的bean。</p>
<p>name属性： 和id类似也是给bean命名。但是name属性的值可以有多个，多个值之间使用英文逗号(,)或者英文分号(;)或者空格符隔开</p>
<h2 id="bean的作用域">Bean的作用域</h2>
<ul>
<li>
<p>prototype</p>
<p>在SpringIOC中prototype scope的意思指的是非单例，就是每次使用该bean的时候都会重新创建一个对象。</p>
<figure data-type="image" tabindex="1"><img src="https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/images/prototype.png" alt="原型作用域示意图"></figure>
</li>
<li>
<p>singleton(默认)</p>
<p>singleton作用域是IOC中默认的作用域，代表单例。每次使用bean的时候，不会重新创建对象，在整个IOC容器中该类型的对象只有一个。</p>
<figure data-type="image" tabindex="2"><img src="https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/images/singleton.png" alt="单例作用域示意图"></figure>
</li>
</ul>
<h2 id="bean的生命周期">Bean的生命周期</h2>
<ul>
<li>Singleton Bean的生命周期
<ul>
<li>初始化时机： 在IOC容器初始化时，就会把配置的所有单例bean实例化。</li>
<li>销毁时机：在IOC容器销毁时，所有bean的销毁方法会被调用。</li>
</ul>
</li>
<li>Prototype Bean的生命周期
<ul>
<li>初始化时机： 在实际使用该bean的时候，比如：getBean、获取依赖此bean的其他bean需要使用</li>
<li>销毁时机： 在IOC容器销毁时。（但是通过destroy-method指定的声明周期方法不会被调用，也就是说Spring不提供prototypebean完整的生命周期管理）</li>
</ul>
</li>
<li>如何指定生命周期的回调方法
<ul>
<li>xml中的init-method、destroy-method</li>
<li>注解方式@PostConstrutor、@PreDestroy</li>
</ul>
</li>
<li>指定默认的声明周期回调方法
<ul>
<li>在xml中，通过在beans标签上添加default-init-method、default-destory-method来指定</li>
<li>在注解配置中，没有对应的方法可以设置所有bean默认的生命周期回调</li>
</ul>
</li>
</ul>
<h2 id="bean懒加载">Bean懒加载</h2>
<p>lazy-init属性</p>
<p>默认是false</p>
<blockquote>
<p>懒加载配置主要是针对单例的bean，因为它默认是在容器初始化时就被实例化了。</p>
</blockquote>
<h2 id="如何优雅的停止非web-spring应用">如何优雅的停止非Web Spring应用</h2>
<p>添加一个shutdown hook。所有派生自ConfigurableApplicationContext接口的实现类都支持此方法</p>
<pre><code class="language-java">ConfigurableApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;xxx.xml&quot;);

ctx.registerShutdownHook(); //注册停止回调
</code></pre>
<h1 id="spring-di">Spring DI</h1>
<h2 id="概述">概述</h2>
<p>DI的全称是Dependency Injection（依赖注入）。IOC是将我们工程中的所有对象交由Spring来管理，DI是此基础，将对象中的属性、依赖的其他对象也管理起来，自动注入到由Spring帮我们管理的对象中。</p>
<blockquote>
<p>将要注入的对象和目标对象都必须是由SpringIOC管理的bean.</p>
</blockquote>
<h2 id="di的细节实现">DI的细节实现</h2>
<h3 id="构造参数注入">构造参数注入</h3>
<p>将一个bean创建过程中构造方法需要的参数，通过Spring DI的方式，自动注入到构造方法中。</p>
<h3 id="setter注入">Setter注入</h3>
<p>先通过一个无参的构造方法创建对象，然后通过属性的setter方法，将属性值注入到对象上。</p>
<h3 id="支持注入的类型">支持注入的类型</h3>
<ul>
<li>
<p>普通字面量</p>
<ul>
<li>String</li>
<li>Integer(int)</li>
<li>Long(long)</li>
<li>Byte(byte)</li>
<li>...</li>
</ul>
</li>
<li>
<p>集和类型</p>
<ul>
<li>
<p>List</p>
<pre><code class="language-xml">&lt;bean id=&quot;xxx&quot; class=&quot;xx.xxx.xxx.AA&quot;&gt;&lt;/bean&gt;
&lt;bean&gt;
    &lt;property name=&quot;hobbies&quot;&gt;
    	&lt;list&gt;
        	&lt;value&gt;简单类型值&lt;/value&gt;
            &lt;bean&gt;内部bean&lt;/bean&gt;
            &lt;ref bean=&quot;xxx&quot; /&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>Map</p>
<pre><code class="language-xml">&lt;bean id=&quot;xxx&quot; class=&quot;xx.xxx.xxx.AA&quot;&gt;&lt;/bean&gt;
&lt;bean&gt;
    &lt;property name=&quot;gameTitle&quot;&gt;
    	&lt;map&gt;
        	&lt;entry key=&quot;王者荣耀&quot; value=&quot;荣耀王者&quot; /&gt;
            &lt;entry key=&quot;王者荣耀&quot; value-ref=&quot;xxx&quot; /&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>Set</p>
<pre><code class="language-xml">&lt;bean id=&quot;xxx&quot; class=&quot;xx.xxx.xxx.AA&quot;&gt;&lt;/bean&gt;
&lt;bean&gt;
    &lt;property name=&quot;hobbies&quot;&gt;
    	&lt;!-- set用法和List类似， 里面可以注入普通字面量值、也可以是一个bean引用，或者内部bean、或者是一个set、list、Properties  --&gt;
        &lt;set&gt;
        	&lt;value&gt;简单类型值&lt;/value&gt;
            &lt;bean&gt;内部bean&lt;/bean&gt;
            &lt;ref bean=&quot;xxx&quot; /&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>java.util.Properties</p>
<pre><code class="language-xml">&lt;!-- props标签是用来注入java.util.Properties类型的属性，用法和map类似，但是属性值是在标签中间写 --&gt;
&lt;property name=&quot;gameNick&quot;&gt;
    &lt;props&gt;
        &lt;prop key=&quot;王者荣耀&quot;&gt;最擅长1V5&lt;/prop&gt;
        &lt;prop key=&quot;吃鸡&quot;&gt;一枪爆头&lt;/prop&gt;
    &lt;/props&gt;
&lt;/property&gt;
</code></pre>
</li>
<li>
<p>注入空置、空字符串</p>
<pre><code class="language-xml">&lt;property name=&quot;gameNick&quot;&gt;
    &lt;null /&gt;
&lt;/property&gt;


&lt;property name=&quot;gameNick&quot; value=&quot;&quot; /&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="自动装配">自动装配</h3>
<h5 id="自动装配支持的策略">自动装配支持的策略</h5>
<ul>
<li>
<p>byType</p>
<p>按照类型去IOC容器中找需要的bean，如果找到一个，则自动装配；如果没找到，不注入此属性；如果找到了多个匹配类型的bean，就会报错。</p>
</li>
<li>
<p>byName</p>
<p>按照名称去IOC容器中找需要的bean，如果找到就自动注入；如果没找到，不注入此属性。</p>
</li>
<li>
<p>constructor</p>
<p>工作原理和byType类似，也是按照类型去IOC容器中找对应的bean。不同的是注入的地方不是setter，而是构造方法的参数。</p>
</li>
<li>
<p>no  （默认值）</p>
<p>如果没有打开自动注入，默认Spring不会自动装配需要的属性。</p>
</li>
</ul>
<h2 id="xml方式的di">XML方式的DI</h2>
<h3 id="构造参数注入-2">构造参数注入</h3>
<ul>
<li>
<p>常规写法</p>
<pre><code class="language-xml">&lt;bean id=&quot;xx&quot; class=&quot;&quot; /&gt;
&lt;bean class=&quot;com.test.XXX&quot;&gt;
	&lt;constructor-arg name=&quot;age&quot; value=&quot;45&quot; /&gt;
    &lt;constructor-arg name=&quot;x&quot; ref=&quot;xx&quot; /&gt;  &lt;!-- 注入引用的bean --&gt;
    &lt;constructor-arg name=&quot;&quot;&gt;	&lt;!-- 注入内部bean --&gt;
    	&lt;bean&gt;&lt;/bean&gt;
    &lt;/constructor-arg&gt;
    &lt;constructor-arg name=&quot;&quot;&gt;	&lt;!-- 注入list类型构造参数 --&gt;
    	&lt;list&gt;
        	
        &lt;/list&gt;
    &lt;/constructor-arg&gt;
    ....
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>c命名空间简写</p>
<pre><code class="language-xml">&lt;bean id=&quot;xx&quot; class=&quot;&quot; /&gt;
&lt;bean class=&quot;com.test.XXX&quot; c:age=&quot;45&quot; c:x-ref=&quot;xx&quot; /&gt;
</code></pre>
</li>
</ul>
<h3 id="setter方式注入">setter方式注入</h3>
<p>setter注入能够注入的类型以及写法基本和构造参数注入时的写法一致，只不过将<construtor-arg>标签换成了<property></p>
<ul>
<li>
<p>常规用法</p>
<pre><code class="language-xml">&lt;bean id=&quot;xx&quot; class=&quot;&quot; /&gt;
&lt;bean class=&quot;com.test.XXX&quot;&gt;
	&lt;property name=&quot;age&quot; value=&quot;45&quot; /&gt;
    &lt;property name=&quot;x&quot; ref=&quot;xx&quot; /&gt;  &lt;!-- 注入引用的bean --&gt;
    &lt;property name=&quot;&quot;&gt;	&lt;!-- 注入内部bean --&gt;
    	&lt;bean&gt;&lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name=&quot;&quot;&gt;	&lt;!-- 注入list类型构造参数 --&gt;
    	&lt;list&gt;
        	
        &lt;/list&gt;
    &lt;/property&gt;
    ....
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>p命名空间简写</p>
<pre><code class="language-xml">&lt;bean id=&quot;xx&quot; class=&quot;&quot; /&gt;
&lt;bean class=&quot;com.test.XXX&quot; p:age=&quot;45&quot; p:x-ref=&quot;xx&quot; /&gt;
</code></pre>
</li>
</ul>
<h3 id="开启自动装配">开启自动装配</h3>
<pre><code class="language-xml">&lt;!-- 
通过给当前的bean添加autowire属性开启自动注入
可选的值：参见自动装配章节
 --&gt;
&lt;bean id=&quot;xx&quot; class=&quot;&quot; autowire=&quot;&quot; /&gt;
</code></pre>
<h3 id="提高自动装配时的权重">提高自动装配时的权重</h3>
<pre><code class="language-xml">&lt;!-- 当其他的bean中需要注入一个Test类型的属性，而满足条件的bean有多个时，会优先注入primary=&quot;true&quot;的bean --&gt;
&lt;bean id=&quot;xx&quot; class=&quot;com.Test&quot; primary=&quot;true&quot; /&gt;
</code></pre>
<h3 id="按类型自动装配时不参与候选">按类型自动装配时，不参与候选</h3>
<pre><code class="language-xml">&lt;!-- 当其他的bean中需要注入一个Test类型的属性，而满足条件的bean有多个时，autowire-candidate=&quot;false&quot;的bean会自动退出候选序列 --&gt;
&lt;bean id=&quot;xx&quot; class=&quot;com.Test&quot; autowire-candidate=&quot;false&quot; /&gt;
</code></pre>
<h2 id="注解方式的di">注解方式的DI</h2>
<ul>
<li>
<p>构造参数注入</p>
<p>在构造方法上添加 <code>@Autowired</code>注解，构造方法的参数就会自动注入进来</p>
</li>
<li>
<p>setter方法注入</p>
<p>方法有两种：</p>
<ol>
<li>在属性的setter方法上添加<code>@Autowired</code>注解</li>
<li>在属性上添加<code>@Autowired</code>注解</li>
</ol>
</li>
</ul>
<h3 id="提高自动装配时的权重-2">提高自动装配时的权重</h3>
<pre><code class="language-java">@Primary
@Component
public class Test {


}

public class Main {
    
    @Primary
    @Bean
    public void test() {
        return new Test();
    }
    
}
</code></pre>
<h2 id="注入外部property文件中的属性值">注入外部Property文件中的属性值</h2>
<h3 id="在xml中的配置方式">在XML中的配置方式</h3>
<pre><code class="language-xml">&lt;!-- 添加context命名空间 --&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;


&lt;!-- 导入外部properties文件到ioc上下文中 --&gt;
&lt;context:property-placeholder location=&quot;jdbc.properties&quot; /&gt;

&lt;!-- 使用占位符的方式获取properties文件中的属性值 --&gt;
&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt;
    &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;
    &lt;property name=&quot;username&quot; value=&quot;${jdbc.user}&quot; /&gt;
    &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="在注解中的配置方式">在注解中的配置方式</h3>
<p>通过<code>@PropertySource</code>注解可以将外部properties文件导入到上下文中，通过<code>@Value</code>注解可以获取properties文件中的属性值，并注入到当前类的属性中</p>
<pre><code class="language-java">@Configuration
@ComponentScan(basePackages = &quot;com.lanou.spring&quot;)
@PropertySource(&quot;classpath:/jdbc.properties&quot;)
public class MyConfiguration {

	@Value(&quot;${jdbc.url}&quot;)
    private String url;
    @Value(&quot;${jdbc.user}&quot;)
    private String username;
    @Value(&quot;${jdbc.password}&quot;)
    private String password;
    @Value(&quot;${jdbc.driver}&quot;)
    private String driverClassName;
}
</code></pre>
<h1 id="springaop">SpringAOP</h1>
<h2 id="概述-2">概述</h2>
<p>AOP的全称是Aspect Oriented  Programming(面向切面编程)</p>
<p>OOP语言提供了类与类之间纵向的关系（继承、接口），而AOP补充了横向的关系（比如在不改变目标类中源代码的情况下给com.john.demo.dao包下所有类中以insert和update开头的方法添加事务管理）</p>
<h3 id="springaop和aspectj的区别">SpringAOP和AspectJ的区别</h3>
<p>AspectJ是一个专门主打面向切面编程的框架。 它是使用一种特殊的语言(扩展自Java语言)来编写切面代码，后缀是.aj格式，并且需要使用专门的编译器将其编译成jvm可以运行的class文件。</p>
<p>SpringAOP底层也是使用了AspectJ的方案，但是在上层做了很多封装层面的工作，可以让开发人员直接使用Java代码来编写切面。并且由于使用的是标准的Java语言，所以并不需要在额外安装一个专门的编译器。但是由于开发人员直接接触的是Spring AOP，那么凡是Spring中没有实现的那些AOP功能，我们就用不了了，这种情况下只能跟产品经理撕逼或者去学习原生的AspectJ。</p>
<h2 id="aop的术语">AOP的术语</h2>
<ul>
<li>
<p>切面（Aspect）</p>
<p>简单来说，切面就是我们要往目标代码中插入进去的代码。</p>
</li>
<li>
<p>连接点（Join Pointer）</p>
<p>理论上所有可能会被切入的地方都可以称之为连接点</p>
</li>
<li>
<p>切入点(Pointcut)</p>
<p>选择某个连接点切入，将切面代码织入进去。这个连接点就叫做切入点。</p>
</li>
<li>
<p>织入(Weaving)</p>
<p>把切面代码糅合到目标代码中的过程就是织入。</p>
</li>
<li>
<p>通知(Advice)</p>
<p>通知决定了切面代码织入到目标代码中后，运行的时机(比如是在目标方法执行前，还是执行后)。</p>
</li>
</ul>
<h2 id="在spring中使用aop">在Spring中使用AOP</h2>
<h3 id="基于xml方式使用">基于XML方式使用</h3>
<ol>
<li>
<p>把aop的schema引入</p>
<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
</code></pre>
</li>
<li>
<p>创建一个切面类，并且以bean的方式配置到IOC容器中</p>
<pre><code class="language-java">package com.lanou3g.spring;
public class MyAspect {

    public void wakeup() {
        System.out.println(&quot;[前置通知]我刚学习SpringAOP睡着了，刚才谁打了我一下？&quot;);
    }


    public void goToBed() {
        System.out.println(&quot;[后置通知]SpringAOP太难了，一不小心又睡着了&quot;);
    }


    public void afterRetuing(Object message) {
        System.out.println(&quot;[后置返回通知]方法执行已经return了，方法返回值是：&quot; + message);
    }

    public void afterThrowing(Throwable ex) {
        System.out.println(&quot;[后置异常通知]方法执行出现异常，异常原因：&quot; + ex.getMessage());
    }

    /**
     * 环绕通知
     * 可以接受一个ProceedingJoinPoint参数
     *      通过此参数可以获取到被切入方法的所有信息
     *      还可以通过此参数来决定是否调用目标方法
     */
    public void aroundAdvice(ProceedingJoinPoint joinPoint) {

        // 连接点参数可以获取到被切入方法的所有信息
        // 这里演示了如何获取被切入方法的名称
        String targetMethodName = joinPoint.getSignature().getName();
        System.out.println(&quot;[环绕通知]被切入的方法名：&quot; + targetMethodName);

        //
        System.out.println(&quot;[环绕通知]即将开始新的一天， 早起的鸟儿有虫吃！&quot;);
        try {
            joinPoint.proceed();
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
        System.out.println(&quot;[环绕通知]这真是充实的一天， 早睡早起，方能养生！&quot;);
    }
}
</code></pre>
<pre><code class="language-xml">&lt;bean id=&quot;myAspect&quot; class=&quot;com.lanou3g.spring.MyAspect&quot; /&gt;
</code></pre>
</li>
<li>
<p>使用<a href="aop:config">aop:config</a>标签配置aop（将切面、切入点、通知结合到一起）</p>
<ol>
<li>定义切入点表达式</li>
<li><a href="aop:aspect">aop:aspect</a>
<ol>
<li>引用外部定义的切面bean</li>
<li>配置通知，引用切入点表达式</li>
</ol>
</li>
</ol>
<pre><code class="language-xml">&lt;aop:config&gt;
    &lt;!-- 切入点表示匹配com.lanou3g.spring包下的所有类中所有以oneDay开头的方法，方法的参数、返回值不限 --&gt;
	&lt;aop:pointcut id=&quot;myPointcut&quot; expression=&quot;execution(* com.lanou3g.spring..*.oneDay*(..))&quot; /&gt;
    &lt;aop:aspect ref=&quot;myAspect&quot;&gt;
    	&lt;!-- 无论是否出现异常，只要被切入的方法开始运行，都会触发此通知 --&gt;
            &lt;aop:before method=&quot;wakeup&quot; pointcut-ref=&quot;beforeOneDay&quot; /&gt;
            &lt;!-- 无论是否出现异常，只要被切入的方法运行结束，都会触发此通知 --&gt;
            &lt;aop:after method=&quot;goToBed&quot; pointcut-ref=&quot;beforeOneDay&quot; /&gt;
            &lt;!--
            可以最大限度的对被切入方法附加功能，在方法执行前、后都可以通知（无论是否出现异常）
            ，还可以获取到被切入方法的所有信息，包括是否调用被切入的方法
            --&gt;
            &lt;aop:around method=&quot;aroundAdvice&quot; pointcut-ref=&quot;beforeOneDay&quot; /&gt;
            &lt;!-- 被切入的方法正常返回值以后，会触发此通知 --&gt;
            &lt;aop:after-returning method=&quot;afterRetuing&quot; pointcut-ref=&quot;beforeOneDay&quot; returning=&quot;message&quot; /&gt;
            &lt;!-- 被切入的方法抛出异常以后，会触发此通知，并且不会触发after-returning --&gt;
            &lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;beforeOneDay&quot; throwing=&quot;ex&quot; /&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre>
</li>
</ol>
<h3 id="基于注解方式使用">基于注解方式使用</h3>
<ol>
<li>
<p>开启AOP注解支持</p>
<p>方式一：注解的方式</p>
<pre><code class="language-xml">@Configuration
@EnableAspectJAutoProxy
public class AppConfig {

}
</code></pre>
<p>方式二：xml中开启</p>
<pre><code class="language-xml">&lt;aop:aspectj-autoproxy/&gt;
</code></pre>
<ol start="2">
<li>定义切面类</li>
</ol>
<pre><code class="language-java">/**
 * 该切面用来插入起床的逻辑
 */
@Aspect
@Component  //@Aspect注解没有将bean交给ioc容器管理的功能
public class MyAspect {

    @Before(&quot;com.lanou3g.spring.aop.MyPointcut.allOneDayMehtod()&quot;)
    public void wakeup() {
        System.out.println(&quot;[前置通知]我刚学习SpringAOP睡着了，刚才谁打了我一下？&quot;);
    }

    @After(&quot;com.lanou3g.spring.aop.MyPointcut.allOneDayMehtod()&quot;)
    public void goToBed() {
        System.out.println(&quot;[后置通知]SpringAOP太难了，一不小心又睡着了&quot;);
    }

    @AfterReturning(value = &quot;com.lanou3g.spring.aop.MyPointcut.allOneDayMehtod()&quot;, returning = &quot;message&quot;)
    public void afterRetuing(Object message) {
        System.out.println(&quot;[后置返回通知]方法执行已经return了，方法返回值是：&quot; + message);
    }

    @AfterThrowing(value = &quot;com.lanou3g.spring.aop.MyPointcut.allOneDayMehtod()&quot;, throwing = &quot;ex&quot;)
    public void afterThrowing(Throwable ex) {
        System.out.println(&quot;[后置异常通知]方法执行出现异常，异常原因：&quot; + ex.getMessage());
    }

    /**
     * 环绕通知
     * 可以接受一个ProceedingJoinPoint参数
     *      通过此参数可以获取到被切入方法的所有信息
     *      还可以通过此参数来决定是否调用目标方法
     */
//    @Around(&quot;com.lanou3g.spring.aop.MyPointcut.allOneDayMehtod()&quot;)
    public Object aroundAdvice(ProceedingJoinPoint joinPoint) {

        // 连接点参数可以获取到被切入方法的所有信息
        // 这里演示了如何获取被切入方法的名称
        String targetMethodName = joinPoint.getSignature().getName();
        System.out.println(&quot;[环绕通知]被切入的方法名：&quot; + targetMethodName);

        //
        System.out.println(&quot;[环绕通知]即将开始新的一天， 早起的鸟儿有虫吃！&quot;);
        Object ret = null;
        try {
            ret = joinPoint.proceed();
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
        System.out.println(&quot;[环绕通知]这真是充实的一天， 早睡早起，方能养生！&quot;);
        return ret;
    }
}
</code></pre>
<blockquote>
<p>注意：@Aspect注解没有将bean交给ioc容器管理的功能，我们需要额外添加一个@Component注解</p>
</blockquote>
<ol start="3">
<li>定义切入点</li>
</ol>
<p>官方建议我们将所有的切入点统一定义到一个地方管理，在配置通知时通过引入的方式来使用。方便后期维护（一处修改，处处生效）</p>
<pre><code class="language-java">@Component
public class MyPointcut {
    // 通过@Pointcut注解定义一个切入点
    @Pointcut(&quot;execution(* oneDay(..))&quot;)
    public void allOneDayMehtod() {}
}
</code></pre>
<ol start="4">
<li>在切面类中添加要切入的代码</li>
</ol>
<blockquote>
<p>参见定义切面部分</p>
</blockquote>
<ol start="5">
<li>在切入的代码方法上添加通知的注解</li>
</ol>
<blockquote>
<p>参见定义切面部分</p>
</blockquote>
</li>
</ol>
<h2 id="spring-aop代理机制实现原理">Spring AOP代理机制实现原理</h2>
<p>Spring AOP底层支持两种动态实现：</p>
<ul>
<li>JDK原生的动态代理</li>
<li>Cglib动态代理</li>
</ul>
<blockquote>
<p>Spring在创建代理对象时，会自动选择要使用哪种代理方案。如果被代理的类实现了接口，那么就用JDK动态代理； 反之就使用Cglib动态代理</p>
</blockquote>
<h3 id="jdk原生动态代理">JDK原生动态代理</h3>
<p>区别静态代理每代理一个类就需要创建一个专门的代理类，动态代理只需要一个通用的代理类，即可代理所有实现了接口的类。</p>
<p>关键的API:</p>
<ul>
<li>
<p>InvocationHandler: 回调接口</p>
<pre><code class="language-java">public class MyProxy implements InvacationHandler {
    /**
     *  此方法在通过代理对象去调用目标方法时，会自动进入此方法(实际上调用的就是此方法)，目标方法时在此方法中调用的(当然，也可以不调用)。

     *  第一个参数proxy: 代理对象(注意不是目标对象)
     *  第二个参数method: 被代理的方法对象(方法本身)
     *  第三个参数args: 代理对象调用时穿进来的参数，用于在代理方法中调用原方法时传入
     *
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

            String methodName = method.getName();

            // 模拟在方法运行前执行的操作
            System.out.println(methodName+ &quot; 开始执行了&quot;);

            Object retVal =  method.invoke(target, args);

            // 模拟在方法运行后执行的操作
            System.out.println(methodName+ &quot; 执行结束了，返回值： &quot; + retVal);

            return retVal;
    }
}
</code></pre>
</li>
<li>
<p>Proxy： 创建代理类的工厂类，用于动态创建代理对象</p>
<ul>
<li>
<p>如何创建代理对象</p>
<pre><code class="language-java">// 1. 创建代理对象
// 参数说明：
//		第一个参数是类加载器
//		第二个参数是被代理类实现的接口，可以写多个(写几个接口就代表你需要代理从几个接口中实现的方法)
//        第三个参数是一个实现了InvacationHandler接口的对象，用于回调
//        当我们通过代理对象去调用目标方法时，会自动执行第三个参数传进来的回调方法
		
Object obj = Proxy.newProxyInstance(classLoader, interfaces..., callback);

// 2. 将类型强转成需要代理类的接口类型
Man man = (Man)obj;

// 3. 通过代理对象去调用原本想调用的方法
man.oneDay();
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="cglib动态代理">Cglib动态代理</h3>
<p>关键的API</p>
<ul>
<li>
<p>Enhancer: 该类负责动态创建代理</p>
<ul>
<li>如何创建代理类</li>
</ul>
<pre><code class="language-java">Enhancer enhancer = new Enhancer();	//类似于一个创建代理对象的工厂类
// 下面三行类似于给工厂对象设置参数
enhancer.setSuperclass(clazz);	// 让动态创建出来的代理类继承指定的类
enhancer.setCallback(this);	 // 指定调用代理对象的方法时，进入的回调方法
return enhancer.create();	// 创建代理对象
</code></pre>
</li>
<li>
<p>MehtodInctercepor: 执行代理对象方法时的回调，作用类似于JDK动态代理中的InvacationHandler</p>
<pre><code class="language-java">public class MyCglibProxy implements MethodInterceptor {

    // 创建动态代理类的工厂对象
    private Enhancer enhancer = new Enhancer();
    public Object getProxy(Class clazz) {
        enhancer.setSuperclass(clazz);
        enhancer.setCallback(this);
        enhancer.setUseCache(false);
        return enhancer.create();
    }

    /**
     *  此方法在通过代理对象去调用目标方法时，会自动进入此方法(实际上调用的就是此方法)，目标方法时在此方法中调用的(当然，也可以不调用)。

     *  第一个参数proxy: 代理对象(注意不是目标对象)
     *  第二个参数method: 被代理的方法对象(方法本身)
     *  第三个参数args: 代理对象调用时穿进来的参数，用于在代理方法中调用原方法时传入
     *  第四个参数methodProxy: 是Cglib提供的一个方法代理对象，代理了第二个参数method,它可以实现直接调用传进来对象的父类上的方法
     */ 
    @Override
    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        String methodName = method.getName();
        System.out.println(methodName + &quot;开始执行了&quot;);
        //代理类对象实例调用父类方法（其实就是调用被代理类上的方法实现）
        Object retVal = methodProxy.invokeSuper(proxy, args);
        System.out.println(methodName + &quot;执行结束了&quot;);
        return retVal;
    }
}
</code></pre>
</li>
</ul>
<h3 id="两种动态代理对比">两种动态代理对比</h3>
<ul>
<li>JDK动态代理要求被代理的类必须是至少实现一个接口才能代理</li>
<li>Cglib动态代理没有上述限制，也就是说他可以代理实现了接口的类，也可以代理没实现接口的类</li>
<li>JDK动态代理创建代理对象的原理是让创建的代理对象实现和被代理类一样的接口，从而代理接口中的方法</li>
<li>Cglib动态代理创建代理对象的原理是让创建的代理对象继承被代理的目标类，从而代理从父类(被代理的类)中继承过来的方法</li>
</ul>
<h3 id="强制使用cglib方式创建代理">强制使用Cglib方式创建代理</h3>
<p>如果上下文入口是XML配置文件</p>
<pre><code class="language-xml">&lt;!-- 方式一. 局部 --&gt;
&lt;aop:config proxy-target-class=&quot;true&quot;&gt;
    &lt;!-- other beans defined here... --&gt;
&lt;/aop:config&gt;

&lt;!-- 方式二. 全局，在开启注解支持的地方添加属性(通过注解配置的AOP) --&gt;
&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;
</code></pre>
<p>如果上下文入口是注解类</p>
<pre><code class="language-java">@EnableAspectJAutoProxy(proxyTargetClass = true) // 开启AOP注解支持,并强制使用cglib代理
public class MyConfiguration {
}
</code></pre>
<h2 id="spring声明式事务">Spring声明式事务</h2>
<h3 id="在xml中使用声明式事务的步骤">在Xml中使用声明式事务的步骤</h3>
<ol>
<li>
<p>添加tx schema</p>
<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
       http://www.springframework.org/schema/tx/spring-tx.xsd
       http://www.springframework.org/schema/aop
       https://www.springframework.org/schema/aop/spring-aop.xsd
        http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
</code></pre>
</li>
<li>
<p>配置数据源</p>
<pre><code class="language-xml">&lt;!-- 导入外部properties文件 --&gt;
&lt;context:property-placeholder location=&quot;jdbc.properties&quot; /&gt;
&lt;!-- 配置数据库连接池 --&gt;
&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
    &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot; /&gt;
    &lt;property name=&quot;username&quot; value=&quot;${jdbc.user}&quot; /&gt;
    &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>配置事务管理器</p>
<pre><code class="language-xml">&lt;!-- 第一步： 配置事务管理器 --&gt;
&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
    &lt;!-- 事务管理器必须依赖数据源 --&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>配置事务通知，同时还能指定一些事务相关的具体属性</p>
<pre><code class="language-xml">&lt;!-- 第二步： 配置事务通知（不同于我们自己之前配置的前置、后置通知，这个是Spring帮我们封装好的，专门用来做事务管理的通知） --&gt;
&lt;!-- tx:advice封装了切面和通知相关的逻辑，不需要我们自己再去编写切面和通知的逻辑 --&gt;
&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
    &lt;tx:attributes&gt;
        &lt;!-- 只有触发了特定异常才回滚事务 --&gt;
        &lt;tx:method name=&quot;*&quot; rollback-for=&quot;Exception&quot; /&gt;
        &lt;!-- 触发以下特定异常，不会回滚事务 --&gt;
        &lt;tx:method name=&quot;*&quot; no-rollback-for=&quot;NullPointerException&quot; /&gt;
        &lt;!-- 配置只读事务，只能查询，不能修改 --&gt;
        &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot; /&gt;
        &lt;!-- 配置事务超时时间，超时后事务自动回滚，单位：秒，
                仅当传播行为propagation设置成REQUIRED或者REQUIRES_NEW的时候有效 --&gt;
        &lt;tx:method name=&quot;find*&quot; timeout=&quot;500&quot; /&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;
</code></pre>
</li>
<li>
<p>配置事务的AOP</p>
<p>其实就是将Spring给我们封装好的事务切面、通知和切入点整合到一起，通过AOP的方式来工作。</p>
<pre><code class="language-xml">&lt;!-- 第三步： 配置AOP --&gt;
&lt;aop:config&gt;
    &lt;aop:pointcut id=&quot;allServiceMethod&quot; expression=&quot;execution(* com.lanou3g.spring.aoptx..*.*(..))&quot;/&gt;
    &lt;!-- 这个advisor类似于我们手工配置的aop:aspect，它将切面、通知和切入点做了一个整合 --&gt;
    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;allServiceMethod&quot; /&gt;
&lt;/aop:config&gt;
</code></pre>
</li>
</ol>
<h3 id="在注解中使用声明式事务的步骤">在注解中使用声明式事务的步骤</h3>
<ol>
<li>
<p>开启注解事务支持</p>
<p>开启注解事务支持有两种方式</p>
<p>方式一： 在xml配置文件中开启</p>
<pre><code class="language-xml">&lt;!-- 开启事务注解扫描 --&gt;
&lt;!-- 如果定义的事务管理器名称就叫transactionManager，则此属性可以省略 --&gt;
&lt;tx:annotation-driven transaction-manager=&quot;txManager&quot; /&gt;
</code></pre>
<p>方式二：在注解配置类上开启，添加<code>@EnableTransactionManagement</code>注解</p>
<pre><code class="language-java">@Configuration
@EnableTransactionManagement
@ComponentScan(basePackages = &quot;com.lanou3g.spring&quot;)
@PropertySource(&quot;classpath:jdbc.properties&quot;)
public class MyConfiguration {
    
}
</code></pre>
</li>
<li>
<p>配置数据源</p>
<pre><code class="language-java">/**
* 配置数据源
* @return
*/
@Bean
public DataSource dataSource() {
    DriverManagerDataSource dataSource = new DriverManagerDataSource();
    dataSource.setDriverClassName(driver);
    dataSource.setUrl(url);
    dataSource.setUsername(user);
    dataSource.setPassword(password);
    return dataSource;
}
</code></pre>
</li>
<li>
<p>配置事务管理器</p>
<pre><code class="language-java">/**
 * 配置事务管理器
 * @param dataSource
 * @return
 */
@Bean
public PlatformTransactionManager transactionManager(DataSource dataSource) {
    return new DataSourceTransactionManager(dataSource);
}
</code></pre>
</li>
<li>
<p>在需要事务管理的方法上添加<code>@Transactional</code>注解</p>
<pre><code class="language-java">// 凡是xml中支持的事务属性，在注解中都有对应的属性来实现，具体属性含义参见xml配置
@Transactional(
    rollbackFor = Exception.class   // 指定哪些异常可以触发事务回滚
    //noRollbackFor =   // 指定事务不回滚哪些异常
    //            isolation =   // 指定事务隔离级别
    //            timeout =     // 指定事务超时时间
    //            propagation = // 指定事务传播行为
    //            readOnly = // 指定只读事务
)
public void login(User user) {

    // Service中只写业务操作代码，不需要关注事务管理
    // 1 更新用户表用户最后登录时间
    user.setLastLoginTime(new Timestamp(System.currentTimeMillis()));
    userDao.updateUser(user);

    int ret = 9 / 0;  // 模拟操作异常

    // 2 插入登录日志
    SystemLog log = new SystemLog();
    log.setAction(&quot;login&quot;);
    log.setOperator(user.getUserName());
    log.setCreateTime(new Date());
    systemLogDao.insertLog(log);
}
</code></pre>
<blockquote>
<p>@Transactional注解除了可以在方法上使用外，还可以在类上。表示类中所有的公开方法都添加此事务管理</p>
</blockquote>
</li>
</ol>
<h3 id="xml方式的事务和注解方式的事务该选哪个">XML方式的事务和注解方式的事务该选哪个？</h3>
<ul>
<li>XML方式的事务
<ul>
<li>优点是对代码没有任何侵入性，修改事务相关逻辑时，只需要修改配置文件，无需重新编译代码。另外XML方式可以通过切入点表达式灵活的对大量的类添加事务管理。</li>
<li>缺点是配置相较于注解方式麻烦一些</li>
</ul>
</li>
<li>注解方式的事务
<ul>
<li>优点是配置简单，使用方便</li>
<li>缺点是无法统一对大量的方法添加事务管理，需要在添加事务的类或方法上一个个添加事务注解，当工程中需要事务管理的代码很多时，工作量就比XML方式还要大。</li>
</ul>
</li>
</ul>
<h3 id="spring事务的传播行为和隔离级别">Spring事务的传播行为和隔离级别</h3>
<h4 id="事务的传播行为">事务的传播行为</h4>
<p>事务传播描述的事务与事务之间的传播关系， 常见的场景是在一个嵌套调用的方法中，外部方法和内部每个方法都添加了事务管理， 不同的传播行为配置，决定了最终是这些方法是使用同一个事务，还是在不同的事务中运行。</p>
<ul>
<li>
<p>PROPAGATION_REQUIRED</p>
<p>支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。</p>
</li>
<li>
<p>PROPAGATION_SUPPORTS</p>
<p>支持当前事务，如果当前没有事务，就以非事务方式执行。</p>
</li>
<li>
<p>PROPAGATION_MANDATORY</p>
<p>支持当前事务，如果当前没有事务，就抛出异常。</p>
</li>
<li>
<p>PROPAGATION_REQUIRES_NEW</p>
<p>新建事务，如果当前存在事务，把当前事务挂起。</p>
</li>
<li>
<p>PROPAGATION_NOT_SUPPORTED</p>
<p>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p>
</li>
<li>
<p>PROPAGATION_NEVER</p>
<p>以非事务方式执行，如果当前存在事务，则抛出异常。</p>
</li>
<li>
<p>PROPAGATION_NESTED</p>
<p>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。</p>
</li>
</ul>
<h4 id="事务的隔离级别">事务的隔离级别</h4>
<p>事务的隔离级别描述的是多个事务之间的可见性问题。比如一个事务还未提交时，其他事务是否能看到被未提交事务修改的数据。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ISOLATION_DEFAULT</td>
<td>这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别.</td>
</tr>
<tr>
<td>ISOLATION_READ_UNCOMMITTED</td>
<td>这是事务最低的隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。 这种隔离级别会产生脏读，不可重复读和幻像读。</td>
</tr>
<tr>
<td>ISOLATION_READ_COMMITTED</td>
<td>保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。 这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。</td>
</tr>
<tr>
<td>ISOLATION_REPEATABLE_READ</td>
<td>这种事务隔离级别可以防止脏读、不可重复读。但是可能出现幻像读。 它保证了一个事务不能修改已经由另一个事务读取但还未提交的数据</td>
</tr>
<tr>
<td>ISOLATION_SERIALIZABLE</td>
<td>这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。 除了防止脏读，不可重复读外，还避免了幻像读。</td>
</tr>
</tbody>
</table>
<h5 id="关键词">关键词：</h5>
<ul>
<li>幻读（虚读）</li>
</ul>
<blockquote>
<p>事务1读取记录时事务2增加了记录并提交，事务1再次读取时可以看到事务2新增的记录；<br>
通俗的说，幻读就是指在一个事务内读取了别的事务插入的数据，导致前后读取不一致(insert)</p>
</blockquote>
<ul>
<li>不可重复读取</li>
</ul>
<blockquote>
<p>事务1读取记录时，事务2更新了记录并提交，事务1再次读取时可以看到事务2修改后的记录；<br>
在一个事务内读取表中的某一行数据,多次读取结果不同.一个事务读取到了另一个事务提交后的数据.</p>
</blockquote>
<ul>
<li>脏读</li>
</ul>
<blockquote>
<p>事务1更新了记录，但没有提交，事务2读取了更新后的行，然后事务T1回滚，现在T2读取无效。<br>
通俗的说，脏读就是指一个事务读取了一个未提交事务的数据</p>
</blockquote>
]]></content>
    </entry>
</feed>